{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>In this course, we will have 4 assignments. Tentatively, we will follow the schedule below.</p> Assignment Release Due Assignment 1 Mon, 20 Jan 2025 Mon, 10 Feb 2025 Assignment 2 Mon, 10 Feb 2025 Mon, 3 Mar 2025 Assignment 3 Mon, 3 Mar 2025 Mon, 31 Mar 2025 Assignment 4 Mon, 31 Mar 2025 Mon, 21 Apr 2025 <p>The maximum score for an assignment is 50 marks. Each assignment will have two parts, i.e.,</p> <ul> <li>Part A (35 marks): some hands-on practice to make you explore aspects about Linux kernel.</li> <li>Part B (15 marks): some exercises that test your understanding on the topics covered in the lectures.</li> </ul> <p>Assignments are always due at 17:59 on some Monday (Singapore time). Late submissions will incur a penalty of 1 mark per hour.</p>"},{"location":"#general-advice","title":"General Advice","text":"<ul> <li>Please read through the instructions before starting.</li> <li>Don't fear making mistakes; they're part of the learning process.   You can always start over and seek help when needed.</li> <li>When you encounter errors, read the messages carefully, especially the first one issued.   They often hold the key to resolving issues.</li> <li>Hone your problem-solving skills by harnessing the vast knowledge available online.</li> </ul> <ul> <li>When submitting code, it is essential to ensure that the code compiles without errors.   A compilation / syntax error will result in a score of ZERO for that question.</li> <li>Use the root user (or <code>sudo</code>) ONLY for operations that really require super-user privileges.   Why is it bad to log in as root?</li> </ul>"},{"location":"#academic-integrity","title":"Academic Integrity","text":"<p>The assignments in this course are all INDIVIDUAL assignments.</p> <p>The assignments are primarily designed as practical experiences to enhance your skills and knowledge. Plagiarism not only negate the benefits of this assignment, but also defeats the purpose of taking the course. These assignments are structured to foster your learning, not to fail students.</p> <p>Plagiarism will not be tolerated and will result in severe consequences in accordance with the University's policy.</p>"},{"location":"#collaboration-and-proper-attribution","title":"Collaboration and Proper Attribution","text":"<p>While collaboration is acceptable to some extent, the assignment questions and tasks should be approached independently. If you receive assistance from classmates, friends, or external resources, you must provide appropriate citations in your submission.</p>"},{"location":"#file-sharing","title":"File Sharing","text":"<p>It is strictly prohibited to share your solution files with individual students or through public channels, such as blog posts. Solution files must not be stored in unprotected directories or repositories. If you use a code repository, like GitHub, ensure that it remains private even after the course concludes. Do not open source your code.</p>"},{"location":"#proper-use-of-ai-tools","title":"Proper Use of AI Tools","text":"<p>We encourage the legitimate and responsible use of AI tools, including ChatGPT, Bard, Bing Chat, and Copilot, to enrich your learning experience.</p> <p>These AI tools can be employed for various educational purposes:</p> <ul> <li>You can seek assistance in proofreading and editing your writing to improve the quality of your work.</li> <li>You can use AI tools to seek explanations for basic concepts, aiding your understanding of course materials.</li> <li>You may request help in explaining pieces of code.</li> </ul> <p>It is strictly prohibited to engage in the following actions:</p> <ul> <li>You must not ask AI tools to generate code on your behalf.</li> <li>You are prohibited from generating content and presenting it as your own work or idea, whether directly or through paraphrasing.</li> <li>Do not use AI tools to process resources not created by you with the intention to plagiarize.</li> </ul>"},{"location":"#feedback","title":"Feedback","text":"<p>If you have any feedback on this assignment, please mail to your TA.</p>"},{"location":"asg1/","title":"Introduction","text":"<p>Info</p> <p>Please read the general instructions first.</p> <p>Part A of the assignment is due 17:59 on 17 Feb 2025.   Part B of the assignment is due 17:59 on 10 Feb 2025.   Late submissions will lose 1 mark per hour.</p> <p>Info</p> <p>These assignments are designed under the assumption that you are using an x86-64 machine.   If you do not have access to a machine based on the x86 architecture, you have the option to request a server for your use.   To proceed with a server request, please complete and submit   this form.   However, in order to ensure the efficient use of resources, we kindly ask that you request a server only if there are no other viable alternatives.</p>"},{"location":"asg1/#part-a-35-marks","title":"Part A (35 marks)","text":""},{"location":"asg1/#task-1-setup-a-virtual-machine","title":"Task 1: Setup a Virtual Machine","text":"<p>Question 1 (2 marks):</p> <p>What is the IP address allocated to your VM? Please take a screenshot of the command and its output that shows the IP address.</p> <p>Please adjust the terminal width to 80-120 characters when you take the screenshot, so that the screenshot is easily readable.</p> <p>Question 2 (3 marks):</p> <p>Different CPUs may have different features even if they are based on the same architecture. SMAP is one of the features commonly available in modern CPUs, but it may not be properly virtualized in some virtual machines. Is SMAP available in the VM you have created? Please write a shell script to check if SMAP is available in the VM.</p> <p>Hint: The <code>xlogin</code> nodes in the SoC Compute Cluster should have SMAP available. You can use it as a reference.</p> <p>Question 3 (3 marks):</p> <p>Whenever you log in to the VM, either locally through the console or remotely via SSH, the system authenticates you using your password or SSH key. These login activities are recorded in the system log file located at <code>/var/log/auth.log</code>. Locate the log entries that record your successful login to the system via SSH, take a screenshot of the relevant section of the log, and highlight on the screenshot:</p> <ul> <li>Which part of the log indicates the login activity occurred via SSH.</li> <li>Is the accepted authentication method, whether it was a password or an SSH key.</li> </ul> <p>Please adjust the terminal width to 80-120 characters when you take the screenshot, so that the screenshot is easily readable.</p> <p>Question 4 (2 marks):</p> <p>It's common need to check how much storage is available in your VM, and this can be done by running the <code>df</code> command. Please refer to the man page of <code>df</code> by executing <code>man df</code> and learn how to</p> <ul> <li>output the available storage in a human-readable format, as well as</li> <li>the type of the filesystems.</li> </ul> <p>Take a screenshot of the command and its output showing the available storage in a human-readable format, along with the type of filesystems. Highlight the line that represents the shared folder.</p> <p>Please adjust the terminal width to 80-120 characters when you take the screenshot, so that the screenshot is easily readable.</p>"},{"location":"asg1/#task-2-build-and-install-linux-kernel","title":"Task 2: Build and Install Linux Kernel","text":"<p>Question 5 (10 marks): Please submit the DEB package <code>linux-image-6.13.0*_6.13.0-*_amd64.deb</code> containing your customized smaller kernel.</p>"},{"location":"asg1/#task-3-explore-the-boot-process","title":"Task 3: Explore the Boot Process","text":"<p>Question 6 (4 marks): Please submit the patch file that modifies the SeaBIOS source code to print your Matric No. below the SeaBIOS version.</p> <p>Please note:</p> <ul> <li>You won't get any marks if the patch cannot be applied to a clean copy of SeaBIOS source code.</li> <li>You won't get any marks if it fails to build after applying your patch.</li> </ul> <p>Question 7 (3 marks): Please submit the source code of the C program <code>dispatch.c</code> that behaves differently depending on the name of the executable.</p> <p>Question 8 (6 marks): Please submit the initramfs image <code>initramfs.cpio.gz</code> which can switch to the root filesystem.</p> <p>Question 9 (2 marks): Which component acts upon the <code>systemd.unit=rescue.target</code> argument? Is it consumed by the (a) BIOS, (b) kernel, (c) initramfs, or (d) after switching to the root filesystem?</p> <p>Please choose ONE of the options above first and then provide a brief explanation.</p>"},{"location":"asg1/#submission-guidelines","title":"Submission Guidelines","text":"<p>Please accept the assignment on GitHub Classroom first. The invitation link is available on Canvas. Then, proceed to complete the tasks and push your work to GitHub accordingly.</p> <p>For all of the following assignments (we will not repeat this every time):</p> <ol> <li> <p>The deadline posted on GitHub is the hard deadline \u2014 you'll lose write access to the repository after that time.    Late penalties will apply starting from the due date on Canvas.</p> </li> <li> <p>Please \"Create a new release\" on GitHub when you're done with your job.    You can create multiple releases, but only the latest release<sup>1</sup> will be graded.    Your submission time (used for calculating late penalties) is based on the time of the release on GitHub.</p> </li> <li> <p>Only push essential files to the repository.    Do not include binaries, object files, or any other files generated from your source code (except explicitly required) in the repository.    Make sure to properly use the <code>.gitignore</code> file to exclude inappropriate files from being pushed to the repository.    If your repository is messy or contains any unnecessary files, there will be a one-time penalty of 2 marks.</p> </li> <li> <p>In the root directory of the repository, there's a file named <code>manifest.json</code> which contains paths to the files submitted for each question.    We will use this file to determine which files to grade.    You SHOULD update this file with the correct paths to your files.</p> </li> <li> <p>There's a script <code>.github/ci.py</code> in the repository that checks if the repository contains essential files for each question.    The script will be executed automatically when you create a release on GitHub.    You can also use the script locally for your own checking.</p> </li> <li> <p>Ensure that your patch can be applied and your code can be compiled.    Otherwise, you will lose all of the marks for the question.</p> </li> </ol> <p>For this assignment:</p> <ol> <li> <p>For Qn5, the DEB package should be uploaded on Canvas and a checksum of the DEB package should be provided in the Git repository.    You can create the checksum using the script <code>task2/generate_checksum</code> in the repository.</p> <ul> <li>Plase Do NOT commit / push the DEB package to this repository.    It's a common practice to exclude large binary files from git repositories.</li> <li>Make sure the the correct checksum of the DEB package is provided.    If the checksum is incorrect, the late penalty will be applied based on the time you submit the DEB package on Canvas or the time you you create the release on GitHub, whichever is later.</li> </ul> </li> <li> <p>For this assignment, you are required to answer Questions 9 in Markdown format.    If you're unfamiliar with Markdown syntax, you can find numerous online tutorials, such as the one available at CommonMark.</p> </li> </ol>"},{"location":"asg1/#part-b-15-marks","title":"Part B (15 marks)","text":"<p>Please complete the quiz Assignment 1 (Part B) on Canvas.</p> <ol> <li> <p>The latest release is the one presented at https://github.com/OWNER/REPO/releases/latest.\u00a0\u21a9</p> </li> </ol>"},{"location":"asg1/task-boot/","title":"Task 3: Experience the Boot Sequence","text":""},{"location":"asg1/task-boot/#installing-qemu","title":"Installing QEMU","text":"<p>QEMU is an open-source machine emulator that allows you to run virtual machines and emulate different architectures on your own system. In this task, we will be leveraging the flexibility of QEMU, particularly its ability to specify a custom firmware or boot directly from a kernel image.</p> <p>To install QEMU on your local machine, open your terminal and execute the following command:</p> <pre><code>sudo apt install qemu-system-x86\n</code></pre> <p>After installing QEMU, you can start using it by running the following command:</p> <pre><code>qemu-system-x86_64 -nographic\n</code></pre> <p>Upon execution, you'll see some output starting with <code>SeaBIOS (version 1.xxx)</code>, followed by some boot attempts. Since we are not providing any bootable image at this point, it's normal for the booting process to fail or hang.</p> <p>You can quit QEMU by pressing <code>Ctrl-a</code> then <code>x</code>. For more commands in this mode, please refer to the manual.</p>"},{"location":"asg1/task-boot/#building-seabios","title":"Building SeaBIOS","text":"<p>SeaBIOS is an open-source implementation of x86 BIOS.</p> <p>First, clone the SeaBIOS repository to get a copy of the source code. You can do this by executing the following command in your terminal:</p> <pre><code>git clone https://git.seabios.org/seabios.git\n</code></pre> <p>Navigate to the cloned repository and build SeaBIOS using the <code>make</code> command.</p> <pre><code>cd seabios &amp;&amp; make\n</code></pre> <p>This will generate a file named <code>bios.bin</code> in the <code>out</code> directory. You can boot into SeaBIOS using the <code>bios.bin</code> file you just built. Run the following command:</p> <pre><code>qemu-system-x86_64 -nographic -bios out/bios.bin\n</code></pre> <p>Upon successful execution, the output should start with <code>SeaBIOS (version rel-1.16.3-xxxxx)</code>. This version should be slightly different from the one you saw previously, indicating that you have successfully booted into the newly built SeaBIOS.</p> <p>Please modify the source code so that your Matric No. (AxxxxxxxY) is printed out below the SeaBIOS version.</p> <p>For submission, commit your changes using <code>git commit</code> and generate a patch file using <code>git format-patch</code>. Please check the man pages for more information on these commands. If you did this correctly, you should be able to apply your patch to a clean copy of the SeaBIOS source code using <code>git apply &lt;patch file&gt;</code>.</p> <p>Question</p> <p>Please submit the patch file that modifies the SeaBIOS source code to print your Matric No. below the SeaBIOS version.</p> <p>Please note:</p> <ul> <li>You won't get any marks if the patch cannot be applied to a clean copy of SeaBIOS source code.</li> <li>You won't get any marks if it fails to build after applying your patch.</li> </ul>"},{"location":"asg1/task-boot/#building-linux-kernel","title":"Building Linux Kernel","text":"<p>You should have already built the kernel in the previous task.</p>"},{"location":"asg1/task-boot/#building-an-initramfs","title":"Building an Initramfs","text":""},{"location":"asg1/task-boot/#create-a-simple-initramfs","title":"Create a simple initramfs","text":"<p>Write a C program named <code>init.c</code> that prints out a message of your choice. Be creative with your message.</p> <pre><code>// Example of init.c\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n</code></pre> <p>Compile your program statically using the command below. This will create an executable named <code>init</code>.</p> <pre><code>gcc -static -o init init.c\n</code></pre> <p>Create a new directory and move the <code>init</code> executable into it. Ensure that the <code>init</code> executable is the only file in this directory. Generate an initramfs from the directory containing your <code>init</code> executable using the following command:</p> <pre><code>find . | cpio -H newc -o | gzip &gt; ../initramfs.cpio.gz\n</code></pre> <p>Boot into the kernel using your newly created initramfs by executing the following command:</p> <pre><code>qemu-system-x86_64 -nographic -append \"console=ttyS0\" -kernel /path/to/bzImage -initrd /path/to/initramfs.cpio.gz\n</code></pre> <p>Replace <code>/path/to/bzImage</code> and <code>/path/to/initramfs.cpio.gz</code> with the actual paths to your kernel image and initramfs respectively.</p> <p>You will encounter a kernel panic. But don't panic! Look for the lines <code>Run /init as init process</code> and <code>Kernel panic - not syncing: Attempted to kill init!</code>. Your message should appear between these two lines. If you see your message, you've successfully built and booted an initramfs.</p>"},{"location":"asg1/task-boot/#create-an-initramfs-using-busybox","title":"Create an initramfs using BusyBox","text":"<p>Start by downloading the latest stable version of the BusyBox source code from the official website: BusyBox. After downloading, extract the source code and navigate to the directory containing the extracted source code.</p> <p>Next, create a configuration using the <code>make menuconfig</code> command. During this process, ensure that you</p> <ul> <li>Enable the \"Build static binary (no shared libs)\" option under \"Settings\".</li> <li>Disable the \"TC\" option under \"Networking Utilities\".</li> </ul> <p>Then, build the source code using <code>make</code> command.</p> <p>After building the source code, install BusyBox using the <code>make install</code> command. This will install BusyBox to the <code>_install</code> directory.</p> <p>You'll notice that most of the executable files under the <code>_install/bin</code> directory are merely links to the <code>busybox</code> executable. Interestingly, despite being links, each of these files can be executed and behaves differently. Try to understand how this functionality is achieved and explain the underlying concept with a brief code snippet.</p> <p>Question</p> <p>To demonstrate your understanding, you are required to write a C program. This program should be compiled into an executable named <code>dispatch</code>. When a link (with different names) to <code>dispatch</code> is executed, it should output different messages based on the filename of the link.</p> <p>Here are the expected outputs for different filenames:</p> Filename Expected Output <code>hello</code> Prints <code>Hello World!</code> <code>user</code> Prints the current username <code>kernel</code> Prints the kernel release version of the current system (e.g., <code>6.7.0-14-generic</code>) <p>Here's an example of how the program should behave:</p> <p></p> <p>Next, create an <code>init</code> script in the <code>_install</code> directory. This script will directly drop to a shell. Here's a sample script, remember to replace <code>&lt;your name&gt;</code> and <code>&lt;your Matric No.&gt;</code> with your actual name and Matric No.:</p> <pre><code>#!/bin/sh\n\nset -ex\necho \"Hello, &lt;your name&gt; (&lt;your Matric No.&gt;)\"\nexec /bin/sh\n</code></pre> <p>The <code>set -ex</code> command facilitates debugging by printing each command before executing it and exiting immediately if any command fails. Remember to make the script executable using the following command:</p> <pre><code>chmod +x init\n</code></pre> <p>Finally, pack all the files in the <code>_install</code> directory into an initramfs using the command used previously. You may use QEMU to test if it works.</p>"},{"location":"asg1/task-boot/#booting-into-ubuntu","title":"Booting into Ubuntu","text":""},{"location":"asg1/task-boot/#create-a-hard-disk-image-for-the-ubuntu-root-filesystem","title":"Create a hard disk image for the Ubuntu root filesystem","text":"<p>Download the Ubuntu 24.04 minimal cloud image from the following link: Ubuntu 24.04 minimal cloud image</p> <p>We will be creating a hard disk image using the downloaded files. First, create a file that is large enough to hold the root filesystem. In this example, we will create a 16 GiB file and format it as an ext4 filesystem using the following commands:</p> <pre><code>fallocate -l 16GiB rootfs.img\nmkfs.ext4 rootfs.img\n</code></pre> <p>Next, mount the image at a temporary location, extract the root filesystem into it, and then unmount it. You can do this using the following commands:</p> <pre><code>mkdir rootfs\nsudo mount -o loop ./rootfs.img ./rootfs\nsudo tar xf ubuntu-24.04-minimal-cloudimg-amd64-root.tar.xz -C rootfs\nsudo umount rootfs\n</code></pre> <p>At this point, the <code>rootfs.img</code> file is a hard disk image that is ready to be used as a root filesystem.</p>"},{"location":"asg1/task-boot/#switch-to-rootfs-from-initramfs","title":"Switch to rootfs from initramfs","text":"<p>BusyBox provides a <code>switch_root</code> command that can be used to switch to a new root filesystem. You will need to find out how to use this command and modify the <code>init</code> script accordingly to switch to the root filesystem.</p> <p>You can then boot into the root filesystem using the following command:</p> <pre><code>qemu-system-x86_64 -nographic -kernel bzImage -initrd busybox.cpio.gz -append 'console=ttyS0' rootfs.img\n</code></pre> <p>Hints:</p> <ul> <li>The <code>rootfs.img</code> is equivalent to a hard disk in the virtual machine launched by QEMU.</li> <li>You will need to have \"proc\" and \"devtmpfs\" mounted in the init script.</li> </ul> <p>Question</p> <p>Please submit the initramfs image <code>initramfs.cpio.gz</code> which can switch to the root filesystem.</p>"},{"location":"asg1/task-boot/#create-a-user","title":"Create a User","text":"<p>The root filesystem that we created does not have any users, which means you cannot log in to it. To create a user, we will boot into the system in single-user mode (rescue mode) and use the <code>useradd</code> command.</p> <p>To boot into rescue mode, add <code>systemd.unit=rescue.target</code> to the kernel command line using the following command:</p> <pre><code>qemu-system-x86_64 -nographic -kernel bzImage -initrd busybox.cpio.gz -append 'console=ttyS0 systemd.unit=rescue.target' rootfs.img\n</code></pre> <p>Once in rescue mode, you can create a user using the <code>useradd</code> command. Please search online for instructions on how to use this command to create a user.</p> <p>Question</p> <p>Which component acts upon the <code>systemd.unit=rescue.target</code> argument? Is it consumed by the (a) BIOS, (b) kernel, (c) initramfs, or (d) after switching to the root filesystem?</p> <p>Please choose ONE of the options above first and then provide a brief explanation.</p>"},{"location":"asg1/task-kbuild/","title":"Task 2: Build and Install Linux Kernel","text":"<p>Warning</p> <p>If you are using the course-provided server, kindly perform this task within your VM. At no point should you attempt to install the kernel built by yourself directly in the server.</p>"},{"location":"asg1/task-kbuild/#fetch-the-kernel-source-code","title":"Fetch the kernel source code","text":"<p>To access the Linux kernel releases, visit the official website at https://www.kernel.org. These releases fall into several main categories: mainline, stable, and long-term. For more information on the different categories, please check this page.</p> <p>In this semester, we will work with the latest mainline release when the course begins, which is Linux 6.13. You can find the repository for the mainline tree at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git and the repository for the stable tree at https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git.</p> <p>To obtain a local copy of the code, we have two options:</p> <ol> <li>Download a release.</li> <li>Clone the repository.</li> </ol> <p>You can choose the method that best suits your needs, as different tasks may require different approaches.</p>"},{"location":"asg1/task-kbuild/#clone-the-tree","title":"Clone the tree","text":"<p>To work with Linux kernel sources and perform tasks such as generating a patch, you'll need to clone the git tree. Use the following command to clone the repository:</p> <pre><code>git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git --depth 1 --branch v6.13\n</code></pre> <p>Here's what each option does:</p> <ul> <li> <p><code>--depth 1</code>:</p> <p>Creates a shallow clone with the history truncated to only one commit, reducing the size of downloaded git objects.</p> </li> </ul> <ul> <li> <p><code>--branch xxx</code>:</p> <p>Specifies the branch (or tag) to clone.</p> </li> </ul>"},{"location":"asg1/task-kbuild/#download-kernel-source-code","title":"Download kernel source code","text":"<p>To download a kernel source code release, visit this link: https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.13.tar.xz.</p> <p>All kernel releases are cryptographically signed. To ensure the integrity of your downloaded kernel releases, follow the instructions provided here.</p>"},{"location":"asg1/task-kbuild/#check-the-version","title":"Check the version","text":"<p>Execute the following command to check which version you currently have:</p> <pre><code>make kernelversion\n</code></pre> <p>If you obtained the kernel source code by cloning the repository, you may also check the commit history:</p> <pre><code>git log -1\n</code></pre>"},{"location":"asg1/task-kbuild/#build-and-install-the-kernel","title":"Build and install the kernel","text":"<p>Additional dependencies</p> <p>In this part, you may encounter errors like:</p> <ul> <li>Command not found: <code>xxx</code></li> <li>Unable to find <code>xxx</code> package</li> <li>...</li> </ul> <p>This indicates that specific programs, libraries, or headers are missing on your machine. You'll need to install the necessary dependencies. Typically, this involves installing Ubuntu software packages required for kernel building. As you continue, you'll become more comfortable with this process.</p>"},{"location":"asg1/task-kbuild/#configure-the-kernel","title":"Configure the kernel","text":"<p>There are several ways to configure the kernel. You can choose one of the following methods:</p> <ul> <li> <p><code>make defconfig</code></p> <p>This command creates a default configuration file for the kernel. The default configuration is a good starting point, but you may want to customize it further.</p> </li> </ul> <ul> <li> <p><code>make menuconfig</code></p> <p>This command opens a menu that allows you to customize the kernel configuration. If there is no configuration file in the current directory, the command will create a new one based on the configuration of the kernel currently running on your machine. It is recommended to use this method if you are not using VirtualBox.</p> </li> </ul> <p>You can check other configuration options by running <code>make help</code>.</p>"},{"location":"asg1/task-kbuild/#build-and-install-linux-kernel","title":"Build and install linux kernel","text":"<ol> <li> <p><code>make -j$(nproc)</code></p> <p>Compiling the kernel is a time-consuming task.  The <code>-j</code> option specifies the number of jobs to run simultaneously.  The <code>nproc</code> command returns the number of processing units available to the current process.  By running multiple jobs in parallel, you can speed up the compilation process.  However, be careful not to overload your machine with too many jobs, as this can cause it to hang.</p> <p>Depending on your machine\u2019s specifications, the compilation process may take 10\u201320 minutes, but YMMV.  While you wait, you can consider ways to optimize the process for future builds.</p> </li> <li> <p><code>make modules_install</code></p> <p>This command is used to install kernel modules.</p> </li> <li> <p><code>make install</code></p> <p>This command installs the newly built kernel.  It's the final step in getting your custom kernel ready for use.  Please try to find out which directory the kernel image is installed to.</p> </li> </ol>"},{"location":"asg1/task-kbuild/#configure-grub","title":"Configure GRUB","text":"<p>The kernel image is now in the correct location. However, the bootloader might not be aware of it yet.</p> <p>The boot order of the operating systems is specified in <code>/boot/grub/grub.cfg</code>. By updating this file, you can modify the default OS, the sequence of different kernel releases, and the behaviour of the GRUB menu.</p> <p>Try to figure out how to update this file (or how the file is updated). The original settings in related files and some online research will be very helpful. Please note that root privileges are required for this step.</p> <p>If this is your first time performing this operation, it is recommended to create a backup or snapshot before proceeding.</p> <p>After rebooting, check whether the boot option appears as expected.</p> <p>Info</p> <p>By default, the GRUB menu is hidden. You can press and hold the <code>Shift</code> key during boot to display the menu. You can also change the default behaviour by modifying the GRUB configuration file.</p> <p></p> <p>If everything goes well, you should see the login prompt. After logging in, some messages (motd) will be printed out. The kernel release version, which should have changed to the new one, is reflected in the first line.</p> <p>It is expected that the new kernel will start up without any problems if you follow the instructions correctly. If something does go wrong, check the error messages and try to figure out what caused the issue. You may ask your friends or the TA for help if you get stuck at this step.</p>"},{"location":"asg1/task-kbuild/#customize-the-kernel-build","title":"Customize the kernel build","text":"<p>In this task, you will build a smaller kernel image that will successfully boot up on your virtual machine. You can do so by customizing the kernel configuration and removing unnecessary features.</p>"},{"location":"asg1/task-kbuild/#menuconfig","title":"menuconfig","text":"<p>To customize the kernel configuration, you may use the <code>menuconfig</code> tool.</p> <pre><code>make menuconfig\n</code></pre> <p>This command will open a menu that allows you to customize the kernel configuration. </p> <p>You will typically encounter three options for most features: <code>built-in</code>, <code>excluded</code>, and <code>module</code>. What do these choices mean, and which one(s) cause the related functions to be included in the kernel image?</p> <p>Feel free to explore other ways to update the config. You may start from checking the information from <code>make help</code>.</p>"},{"location":"asg1/task-kbuild/#shrink-the-kernel-image","title":"Shrink the kernel image","text":"<p>Please try to shrink the kernel image by removing unnecessary features. Please note:</p> <ul> <li>Keep the original kernel for comparison.</li> <li>Give your smaller kernel a different name from the one built in the previous task.   You can add suffix to the kernel release version by updating <code>LOCALVERSION</code> in the kernel config to identify your kernel images.   Use the search function of <code>menuconfig</code> to find where to modify the option.</li> <li>To check if the VM has successfully booted up, verify that the VM reaches the same login screen as your original kernel.</li> <li>Your goal is to reduce the size of the kernel image (<code>./arch/x86/boot/bzImage</code>) to no larger than 8 MiB (8388608 bytes).   You'll get at least 2 marks if the kernel image is smaller than 10 MiB and full marks if it's smaller than 8 MiB.   There's no need to shrink it excessively.</li> </ul> <p>Info</p> <p>When you attempt to boot with your new kernel after removing certain features, expect something strange to happen. It's a good idea to document the changes you made to the kernel configuration. This record will be handy in figuring out the cause of any issues that arise. This part of the assignment is designed to prompt you to observe the effects of disabling specific features, understand their importance, and then work on fixing any resulting problems.</p> <p>For your submission, build your customized kernel into a DEB package using the following command:</p> <pre><code>make bindeb-pkg\n</code></pre> <p>You may need additional dependencies to build the DEB package successfully. After doing so, several new files should be generated in the parent folder (not the current directory). Submit the file whose name starts with <code>linux-image</code>. You can check the file using the commands below:</p> <ol> <li><code>dpkg -c linux-image-6.13.0*_6.13.0-*_amd64.deb</code>    This command lists the contents of the DEB package.    Inside the package, there should be a file named <code>./boot/vmlinuz-6.13.0...</code>.    If not, you might be looking at the wrong file.</li> <li> <p><code>dpkg -f linux-image-6.13.0*_6.13.0-*_amd64.deb Maintainer</code>    This command extracts the <code>Maintainer</code> information from the control file in the DEB package.    The output should be like:</p> <pre><code>user &lt;user@hostname&gt;\n</code></pre> <p>Please note: <code>user</code> should not be <code>root</code>.</p> </li> </ol> <p>Question</p> <p>Please submit the DEB package <code>linux-image-6.13.0*_6.13.0-*_amd64.deb</code> containing your customized smaller kernel on Canvas.</p> <ul> <li>You should upload the DEB package on Canvas, and a checksum file in the Git repository.   The checksum file can be generated using the script provided in repository.   <pre><code>task2/generate_checksum /path/to/deb/package\n</code></pre></li> <li>The DEB package must boot up successfully on your VM.   If your kernel boots up successfully, you'll get some marks based on the size of the kernel image.</li> </ul>"},{"location":"asg1/task-vm/","title":"Task 1: Setup a Virtual Machine","text":"<p>It is common to have problems during the setup stage. Try to figure it out yourself first. Remember to read the error messages carefully and search online for solutions. The abilities to search and debug is crucial in dealing with Linux.</p> <p>However, if you cannot find solutions after you try all approaches you can think of, feel free to discuss it with your classmates or email the TA.</p> <p>Not using an x86 machine?</p> <p>These assignments are designed with the assumption that you're using an x86-64 machine. If you don't have access to an x86-based machine, you should have already requested a server for your assignments.</p> <p>Please note that you won't have access to the graphical interface of the remote machine, so additional steps may be required. Refer to the relevant tabs for instructions tailored to your situation.</p> Local MachineRemote Server <p>These instructions are for students who are using their own x86 machines.</p> <p>These instructions are for students who are using the remote server provided by the course.</p>"},{"location":"asg1/task-vm/#install-virtualbox-on-your-machine","title":"Install VirtualBox on your machine","text":"Local MachineRemote Server <p>VirtualBox is an open-source software that runs on most common platforms. Please download the latest version from page and install it on your machine. It should work on all major x86-based platforms.</p> <p>You'll still be working with VirtualBox.</p> <p>For some parts of the assignment, you will need to operate the machine even before the operating system is fully booted. Therefore, it is necessary to work in a virtual machine under your full control, even though the server is already pre-installed with Ubuntu.</p> <p>The server we provide already has VirtualBox and the extension pack installed. You can use the following command to check the version of VirtualBox:</p> <pre><code>$ VBoxManage --version\n7.0.16_Ubuntur162802\n</code></pre>"},{"location":"asg1/task-vm/#download-an-iso-image-of-linux-ubuntu","title":"Download an ISO image of Linux Ubuntu","text":"<p>You can download the Ubuntu Server 24.04.1 LTS install image for a 64-bit machine from here or from Ubuntu's official website.</p>"},{"location":"asg1/task-vm/#create-and-launch-a-virtual-machine","title":"Create and launch a virtual machine","text":"Local MachineRemote Server <ol> <li>Start VirtualBox</li> <li>Click \"New\" button in the Oracle VM VirtualBox Manager.</li> <li>Use the setting listed below<ul> <li>Name and the Operating System<ul> <li>Name: CS5250 (or anything you like)</li> <li>ISO Image: Choose the ISO file you downloaded</li> <li>Check \"Skip Unattended Installation\"</li> </ul> </li> <li>Hardware<ul> <li>Base Memory: 2048 MB (or larger, you can change this when needed)</li> <li>Processors: 2 (or more, you can change this when needed)</li> </ul> </li> <li>Hard Disk<ul> <li>Create a virtual hard disk now.</li> <li>Allocate at least 40 GB</li> </ul> </li> </ul> </li> <li>Click \"Finish\"</li> </ol> <p>Start your virtual machine by clicking \"Start\" in VirtualBox Manager.</p> <p>You will use the <code>VBoxManage</code> command to create and manage your virtual machine. After that, you can then connect to it from your local machine via the Remote Desktop Protocol.</p> <p>For an overview of how to create a VM on a headless server, refer to Section 7.1.3. Keep the following points in mind:</p> <ul> <li>The example provided in the manual is for Windows XP, but we intend to use Linux as the Guest OS.   Adjust the <code>ostype</code> accordingly to match your requirements.   You may find the list of supported OS types using <code>VBoxManage list</code> command (see here).</li> <li>When configuring your VM, choose an appropriate number of CPUs, memory size, and virtual hard disk size.   We recommend setting it to 2 CPUs, 2 GB of memory, and 40 GB of disk space.</li> </ul> <p>Here\u2019s a sample script to create and configure a VM. Use it with caution and adjust it according to your requirements. Copying and pasting the script without reviewing it is highly discouraged.</p> <pre><code># Create a virtual machine\nVBoxManage createvm --name &lt;VM-name&gt; --ostype \"Ubuntu_64\" --register\n\n# Configure virtual hardware resources\nVBoxManage modifyvm &lt;VM-name&gt; --cpus 2 --memory 2048\n\n# Create a virtual hard disk (40GiB)\npushd \"$HOME/VirtualBox VMs/&lt;VM-name&gt;\"\nVBoxManage createmedium disk --filename \"&lt;VM-name&gt;.vmdk\" --size 40960 --format VMDK\nVBoxManage storagectl &lt;VM-name&gt; --name \"SATA Controller\" --add sata --controller IntelAHCI\nVBoxManage storageattach &lt;VM-name&gt; --storagectl \"SATA Controller\" --port 0 --device 0 --type hdd --medium \"&lt;VM-name&gt;.vmdk\"\npopd\n\n# Create a virtual DVD drive with installation ISO\nVBoxManage storagectl &lt;VM-name&gt; --name \"IDE Controller\" --add ide\nVBoxManage storageattach &lt;VM-name&gt; --storagectl \"IDE Controller\" --port 0 --device 0 --type dvddrive --medium /path/to/ubuntu-24.04.1-live-server-amd64.iso\n\n# Enable VRDP\nVBoxManage modifyvm &lt;VM-name&gt; --vrde on\n</code></pre> <p>You may use the following command to check the configuration of your VM:</p> <pre><code>$ VBoxManage showvminfo cs5250\n</code></pre> <p>A RDP client is needed to connect to the VM. For Mac users, you can install \"Windows App\" from the App Store.</p> <p>The VRDP server that comes with VirtualBox typically uses TCP port 3389 by default. However, for security reasons, this port is disabled using ufw on the server. You should use SSH port forwarding to map the VRDP port to your local machine by executing the following command on your local machine:</p> <pre><code>ssh -L 3389:localhost:3389 &lt;username&gt;@&lt;server-ip&gt;\n</code></pre> <p>This command establishes a secure SSH tunnel, forwarding traffic from port 3389 on your local machine to port 3389 on the server, facilitating secure access to the VRDP server on the remote machine as if it were running locally.</p> <p>Then you can start the virtual machine by executing the following command on the server:</p> <pre><code>$ VBoxHeadless --startvm &lt;VM-name&gt;\nOracle VM VirtualBox Headless Interface 7.0.16_Ubuntu\nCopyright (C) 2008-2024 Oracle and/or its affiliates\n\nStarting virtual machine: VRDE server is listening on port 3389.\n10%...20%...30%...40%...50%...60%...70%...80%...90%...100%\n</code></pre> <p>Once initiated, connect to the virtual machine using your RDP client. Since the port has been forwarded to your local machine, set the \"PC name\" as either <code>localhost</code> or <code>127.0.0.1</code>. If you are required to enter a username and password, use the username you used to SSH into the server and the password you set.</p> <p>Remove VNC Extension Pack</p> <p>When installing the VirtualBox Extension Pack, a VNC extension pack may be installed by default. This extension pack may cause conflicts with the VRDP server. If you have trouble connecting to the VRDP server, you may try uninstalling the VNC extension pack.</p> <p>You may check if the VNC extension pack is installed using the following command:</p> <pre><code>$ VBoxManage list extpacks\nExtension Packs: 2\nPack no. 0:   VNC\nVersion:        7.0.16\nRevision:       162802\nEdition:\nDescription:    VNC plugin module\nVRDE Module:    VBoxVNC\nCrypto Module:\nUsable:         true\nWhy unusable:\n\nPack no. 1:   Oracle VM VirtualBox Extension Pack\nVersion:        7.0.16\nRevision:       162802\nEdition:\nDescription:    Oracle Cloud Infrastructure integration, Host Webcam, VirtualBox RDP, PXE ROM, Disk Encryption, NVMe, full VM encryption.\nVRDE Module:    VBoxVRDP\nCrypto Module:  VBoxPuelCrypto\nUsable:         true\nWhy unusable:\n</code></pre> <p>If the VNC extension pack is installed, you can uninstall it using the following command:</p> <pre><code>$ sudo VBoxManage extpack uninstall VNC\n[sudo] password for sadm:\n0%...10%...20%...30%...40%...50%...60%...70%...80%...90%...100%\nSuccessfully uninstalled \"VNC\".\n</code></pre>"},{"location":"asg1/task-vm/#install-os-for-your-vm","title":"Install OS for your VM","text":"<p>Follow the guided installation process to install Ubuntu on your virtual machine. Please take note of the following settings:</p> <ul> <li>Keyboard configuration:   If you are using a Mac keyboard, the layout may be different from the standard ANSI or ISO ones.   You may try a \"Keyboard Variant\" ending with <code>(Macintosh)</code>.</li> <li>Guided storage configuration:   Please uncheck the \"Set up this disk as an LVM group\" option.</li> <li>Profile configuration:<ul> <li>Name: Enter your full name.</li> <li>Server's Name: Choose a name that starts with your NUSNET ID.</li> <li>Username: Choose a username that is formed from your real name.</li> <li>Password: Choose a secure password.</li> </ul> </li> <li>SSH configuration:<ul> <li>Ensure to check the \"Install OpenSSH server\" option.</li> </ul> </li> </ul> <p>After reboot, you shall see some logs doing initial setup, which is output by \"cloud-init\". When it is done, press \"Enter\" and you should see the login prompt.</p> <pre><code>&lt;hostname&gt; login:\n</code></pre> <p>To login, input your username, press \"Enter\", and then input your password<sup>1</sup> as required. And you will see the bash prompt.</p> <pre><code>user@&lt;hostname&gt;:~$\n</code></pre> <p>As a beginner, you may try to find and print the information below.</p> <ul> <li>The OS version and the kernel release version</li> <li>The IP address allocated, and your MAC address</li> </ul> <p>Question</p> <p>What is the IP address allocated to your VM? Please take a screenshot of the command and its output that shows the IP address.</p> <p>Please adjust the terminal width to 80-120 characters when you take the screenshot, so that the screenshot is easily readable.</p> <p>Question</p> <p>Different CPUs may have different features even if they are based on the same architecture. SMAP is one of the features commonly available in modern CPUs, but it may not be properly virtualized in some virtual machines. Is SMAP available in the VM you have created? Please write a shell script to check if SMAP is available in the VM.</p> <p>Hint: The <code>xlogin</code> nodes in the SoC Compute Cluster should have SMAP available. You can use it as a reference.</p>"},{"location":"asg1/task-vm/#setting-up-ssh-connection","title":"Setting up SSH connection","text":"<p>Configure the virtual machine to allow connection via SSH from the host<sup>2</sup> machine. Once the SSH connection is set up, you can access the VM from your host machine using a terminal or an SSH client. You can even attach VSCode to the VM for a better experience.</p> <p>To achieve this, you will need to modify the network settings of the VM and configure port forwarding to make the VM\u2019s SSH port accessible from the host machine.</p> <p>Question</p> <p>Whenever you log in to the VM, either locally through the console or remotely via SSH, the system authenticates you using your password or SSH key. These login activities are recorded in the system log file located at <code>/var/log/auth.log</code>. Locate the log entries that record your successful login to the system via SSH, take a screenshot of the relevant section of the log, and highlight on the screenshot:</p> <ul> <li>Which part of the log indicates the login activity occurred via SSH.</li> <li>Is the accepted authentication method, whether it was a password or an SSH key.</li> </ul> <p>Please adjust the terminal width to 80-120 characters when you take the screenshot, so that the screenshot is easily readable.</p>"},{"location":"asg1/task-vm/#setting-up-shared-folder","title":"Setting up shared folder","text":"<p>A shared folder is a directory can be accessed and used by both the host machine (where VirtualBox is installed) and the guest virtual machine (VM) running within VirtualBox. This feature allows for the seamless exchange of files between the host<sup>2</sup> and the VM.</p> <p>Please create a folder on your host machine and make it accessible to the VM.</p> <p>Question</p> <p>It\u2019s common need to check how much storage is available in your VM, and this can be done by running the <code>df</code> command. Please refer to the man page of <code>df</code> by executing <code>man df</code> and learn how to</p> <ul> <li>output the available storage in a human-readable format, as well as</li> <li>the type of the filesystems.</li> </ul> <p>Take a screenshot of the command and its output showing the available storage in a human-readable format, along with the type of filesystems. Highlight the line that represents the shared folder.</p> <p>Please adjust the terminal width to 80-120 characters when you take the screenshot, so that the screenshot is easily readable.</p>"},{"location":"asg1/task-vm/#recovery-optional","title":"Recovery (Optional)","text":"<p>In case you encounter an irreparable issue with the VM, simply repeat the aforementioned steps to set up a new one. However, any work previously done will be lost.</p> <p>Creating a snapshot of your virtual machine can be a lifesaver. A snapshot captures the current state of the virtual machine, which you can revert to at any time. This means if something goes wrong, you won't lose all your work - you can simply revert to the snapshot. But that takes up disk space, so use it sparingly.</p> <ol> <li> <p>In case you don't know, the password you type will not be displayed on the screen. Please just type it blindly and press \"Enter\".\u00a0\u21a9</p> </li> <li> <p>\"Host\" refers to the machine where VirtualBox is installed and running. For instance, if you run VirtualBox locally on your Windows laptop, the \"host\" refers to Windows. If you are using a MacBook with VirtualBox installed remotely on a server, the \"host\" refers to the remote server rather than your MacBook.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"asg2/","title":"Introduction","text":"<p>Info</p> <p>Please read the general instructions first.</p> <p>Part A of the assignment is due 17:59 on 10 Mar 2025 Part B of the assignment is due 17:59 on 3 Mar 2025 Late submissions will lose 1 mark per hour.</p>"},{"location":"asg2/#part-a-35-marks","title":"Part A (35 marks)","text":"<p>Info</p> <p>Please accept the assignment on GitHub Classroom before proceeding, as some code snippets are provided in the repository. The invitation link is available on Canvas.</p> <p>Info</p> <p>Throughout this assignment, you will be working with the Linux kernel version 6.13. Please start with the default configuration and make the following two features enabled:</p> <ul> <li>Kernel hacking<ul> <li>Compile-time checks and compiler options<ul> <li>Debug information<ul> <li>Rely on the toolchain's implicit default DWARF version (<code>DEBUG_INFO_DWARF_TOOLCHAIN_DEFAULT [=y]</code>)</li> </ul> </li> <li>Provide GDB scripts for kernel debugging (<code>GDB_SCRIPTS [=y]</code>)</li> </ul> </li> </ul> </li> </ul> <p>If you need VirtualBox shared folders, ensure that <code>CONFIG_VBOXGUEST</code> and <code>CONFIG_VBOXSF_FS</code> are enabled in your kernel configuration.</p> <p>It may require more memory to build the kernel with these features enabled. If you encounter OOM errors during the build process, please increase the memory of your VM to at least 3 GB.</p>"},{"location":"asg2/#optional-get-around-in-the-source-code-tree","title":"Optional: Get Around in the Source Code Tree","text":""},{"location":"asg2/#task-1-debugging-with-gdb","title":"Task 1: Debugging with GDB","text":"<p>Question 1 (2 marks): Which figure in the ABI documentation describes the stack layout for the initial state of a process?</p> <p>Question 2 (2 marks): Which interrupt line (IRQ) is allocated for this specific interrupt?</p> <p>Question 3 (4 marks): How does the <code>/init</code> program get executed? Is this procedure similar to how <code>execve</code> works? Does a context switch occur, similar to what happens during a <code>syscall</code>? Please explain your observation briefly.</p>"},{"location":"asg2/#task-2-developing-a-kernel-module","title":"Task 2: Developing a Kernel Module","text":"<p>Question 4 (2 marks): Identify the file and line number where the <code>module_init</code> macro is defined for our scenario.</p> <p>Please give your answer in the format <code>file#L1234</code>. For example, if it were defined in kernel/sched/core.c at line 6636, you should refer to it as <code>kernel/sched/core.c#L6636</code>.</p> <p>Question 5 (2 marks): Why is <code>printk</code> used instead of <code>printf</code> within kernel modules?</p> <p>Question 6 (2 marks): Did you observe the output \"Greetings from xxx\" when you loaded the module? If not, is this string compiled into the module? Please explain your observation briefly.</p> <p>Question 7 (2 marks): Modify the Makefile, if necessary, to make the message compiled into the module.</p> <p>Question 8 (4 marks): Submit the source code for your kernel module. The module shall accept two parameters and output the process ID and executable name for the given PID. Ensure that the module compiles without errors using the Makefile and that it can be loaded and unloaded without any error.</p> <p>Question 9 (3 marks): Submit the Makefile that builds and loads the kernel module. The Makefile should include two additional targets beyond those in the previously provided Makefile.</p> <ol> <li><code>insmod</code> loads the module with the appropriate arguments.    The command that uses this target should be:    <pre><code>$ sudo make insmod tag=xxx pid=yyy\n</code></pre></li> <li><code>rmmod</code> unloads the module.    The command that uses this target should be:    <pre><code>$ sudo make rmmod\n</code></pre></li> </ol>"},{"location":"asg2/#task-3-creating-a-new-system-call","title":"Task 3: Creating a New System Call","text":"<p>Question 10 (8 marks): Please provide the patch file for the changes you made to the kernel source code to create the new system call. The patch file should have suffix <code>.patch</code> and adhere to the following requirements:</p> <ul> <li>The patch file must be able to be applied to the v6.13 version of the kernel source code without any errors.   If the patch file cannot be applied, you will receive zero marks for this question.</li> <li>The patched kernel must be able to compile without any errors.   If the patched kernel cannot compile, you will receive zero marks for this question.</li> </ul> <p>Question 11 (4 marks): Please provide the source code for your user-mode program in a C file. This program should take the PID of a process as input, invoke the new system call you created, and output the PIDs of all its children, one per line. Please ensure that the program compiles without error.</p>"},{"location":"asg2/#submission-guidelines","title":"Submission Guidelines","text":"<p>Please accept the assignment on GitHub Classroom first. The invitation link is available on Canvas. Then, proceed to complete the tasks and push your work to GitHub accordingly.</p> <p>Refer to the submission guidelines in Assignment 1 for the remaining instructions.</p> <p>For this assignment:</p> <ol> <li>Questions 1, 2 and 4 shall be answered in the <code>manifest.json</code> file directly.</li> </ol>"},{"location":"asg2/#part-b-15-marks","title":"Part B (15 marks)","text":"<p>Please complete the quiz Assignment 2 (Part B) on Canvas.</p>"},{"location":"asg2/task-browsing/","title":"Optional: Get Around in the Source Code Tree","text":"<p>Warning</p> <p>This task is for your self-exploration only. You are not required to submit any answers for this task. It is not graded and does not contribute to your final mark.</p> <p>In this task, we introduce how to navigate the Linux kernel source code using <code>clangd</code> and <code>VSCode</code>. With these tools, you can easily browse the kernel source code and focus on active parts of the code. That is, code disabled by the kernel configuration will appear greyed out. This is different from the Elixir Cross Referencer, which shows all the code without considering the specific kernel configuration.</p> <p>Several other tools are available to help navigate the kernel source code. You may check this page to see if they better suit your needs.</p>"},{"location":"asg2/task-browsing/#navigate-the-linux-kernel-source-code-with-clangd-and-vscode","title":"Navigate the Linux Kernel Source Code with <code>clangd</code> and VSCode","text":"<p><code>clangd</code> is a language server that indexes the source code and provides features like code completion, navigation, and refactoring. You may check this page to see what you can do with it on VSCode.</p> <p>If you prefer using other editors or IDEs, you can refer to this page for a list of other editors/IDEs compatible with <code>clangd</code>.</p> <p>Below is a brief guide to setting up <code>clangd</code> and <code>VSCode</code>. For more detailed instructions, you can search the web or ask ChatGPT for assistance:</p> <ol> <li>Build the kernel on your Linux machine as usual.</li> <li>Run <code>./scripts/clang-tools/gen_compile_commands.py</code> in the kernel source tree to generate the <code>compile_commands.json</code> file.</li> <li>Install VSCode on your local machine.</li> <li>Install the \"remote-ssh\" and \"clangd\" extensions from the Extension Marketplace in the VM.</li> <li>Connect to the VM using the \"remote-ssh\" extension in VSCode.</li> <li>Use \"open folder\" to open the kernel source tree in VSCode.</li> <li>Open a C file within the kernel source tree.    If <code>clangd</code> is not installed, you will see a prompt at the bottom-right corner of the window asking you to install <code>clangd</code>.    Click \"Install\" to proceed.</li> </ol> <p>Note: If you have the official \"C/C++\" extension installed, you may need to disable it to prevent conflicts with <code>clangd</code>.</p> <p>To try this out, open the file <code>kernel/sched/core.c</code> at line 6636, where the <code>__schedule</code> function is defined. This function serves as the main scheduler function, driving the scheduling process in the Linux kernel. You may find a call to the <code>context_switch</code> function at line 6756. To navigate to its definition, right-click on the function name and select \"Go to Definition.\"</p>"},{"location":"asg2/task-gdb/","title":"Task 1: Debugging with GDB","text":"<p>Info</p> <p>Wherever we mention the \"ABI documentation\", we are referring to the document available at https://refspecs.linuxfoundation.org/elf/x86_64-abi-0.99.pdf. This link is also available on Canvas.</p> <p>Info</p> <p>We assume you have some basic familiarity with GDB. If GDB is completely new to you, consider reviewing these resources from CS:APP beforehand:</p> <ul> <li>Beej's Guide to GDB:   https://beej.us/guide/bggdb/</li> <li>An x86-64 GDB Cheat Sheet:   http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.txt</li> </ul> <p>For additional support, you might find the following resources helpful:</p> <ul> <li>The Official GDB Manual, Debugging with GDB:   https://sourceware.org/gdb/current/onlinedocs/gdb/</li> </ul>"},{"location":"asg2/task-gdb/#examining-the-stack","title":"Examining the Stack","text":"<p>Write a C program by creating a file named <code>hello.c</code> with the following content:</p> <pre><code>// hello.c\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, world!\\n\");\n    return 0;\n}\n</code></pre> <p>Compile the program using the command below. The <code>-g</code> flag compiles your program with debug information, which is important for debugging.</p> <pre><code>gcc -Og -g -o hello hello.c\n</code></pre> <p>Run the compiled program using GDB with the command:</p> <pre><code>gdb ./hello\n</code></pre> <p>At this point, the program is loaded into GDB but has not started executing. To begin execution up to the start of the <code>main</code> function, use the <code>start</code> command.</p> <pre><code>(gdb) start\n</code></pre> <p>Upon executing the <code>start</code> command, GDB will output something similar to:</p> <pre><code>Temporary breakpoint 1, main () at hello.c:4\n</code></pre> <p>This message indicates that a temporary breakpoint has been set at the beginning of the <code>main</code> function and the program is paused at this point. You can examine the state of the program at this breakpoint.</p> <p>To view the register values at this point, use the <code>info registers</code> command in GDB. This command displays the current values of all registers.</p> <pre><code>(gdb) info registers\n</code></pre> <p>To examine the first 8 values on the stack in hexadecimal format, use the <code>x/8xg $rsp</code> command. This command uses the <code>x</code> command to examine memory and prints 8 quadwords (<code>g</code> stands for giant/quadword) in hexadecimal format from the location pointed to by the stack pointer (<code>rsp</code>).</p> <pre><code>(gdb) x/8xg $rsp\n</code></pre> <p>Refer to \"Figure 3.4: Register Usage\" in the ABI documentation. Check what the first three arguments passed to the <code>main</code> function are. For help with format specifiers, check the GDB manual's section on Examining Memory.</p> <p>To exit GDB, use the <code>quit</code> command.</p> <p>Restart the <code>hello</code> program in GDB, this time using the <code>starti</code> command. You'll notice the program pauses at <code>_start</code> instead of <code>main</code>. What is the difference between <code>start</code> and <code>starti</code>?</p> <p>Then, output the first few quadwords on the stack. Among these, you'll identify values that appear to be addresses, not too far from the top of the stack. Try printing the content at these addresses using various formats to understand what are they.</p> <p>Finally, check the ABI documentation to verify your findings.</p> <p>Question</p> <p>Which figure in the ABI documentation describes the stack layout for the initial state of a process?</p>"},{"location":"asg2/task-gdb/#attach-gdb-to-kernel-via-qemu","title":"Attach GDB to Kernel via QEMU","text":"<p>Please build the kernel with the following TWO configuration options set:</p> <p>Use the following command to start Linux kernel in QEMU. The <code>-s</code> option configures QEMU to listen for a GDB connection on port 1234. The <code>-S</code> option pauses the CPU at startup, providing an opportunity to connect with GDB prior to the kernel's execution. Additionally, KASLR is disabled to simplify the debugging process.</p> <pre><code>qemu-system-x86_64 -s -S -nographic -kernel ./arch/x86/boot/bzImage -append 'console=ttyS0 nokaslr'\n</code></pre> <p>Info</p> <p>For more details on QEMU's command-line options and key bindings in the character backend multiplexer, you can refer to the QEMU documentation.</p> <p>Next, open a new terminal and start GDB. Use the <code>vmlinux</code> file located in the root directory of the kernel source code. This file is an uncompressed kernel image that includes debugging information.</p> <pre><code>gdb vmlinux\n</code></pre> <p>Inside GDB, connect to the GDB server in the active QEMU instance using:</p> <pre><code>(gdb) target remote localhost:1234\n</code></pre> <p>This allows you to set breakpoints, continue execution, and inspect the kernel's state.</p> <p>Info</p> <p>You may find it troublesome to type the \"target remote\" commands every time you start GDB. To automate this process, you can create a file named, say, <code>gdbinit</code> with the following content:</p> <pre><code>target remote localhost:1234\n</code></pre> <p>Then, you can start GDB with the following command:</p> <pre><code>gdb -x gdbinit vmlinux\n</code></pre> <p>This will automatically execute the commands in <code>gdbinit</code> when GDB starts, i.e., connect to the QEMU instance. You may also add other commands to <code>gdbinit</code> to further automate the debugging process if needed.</p> <p>For an initial exploration, let's monitor changes to the <code>jiffies_64</code> variable. Use the <code>watch</code> command:</p> <pre><code>(gdb) watch jiffies_64\n</code></pre> <p>Continue the execution with:</p> <pre><code>(gdb) continue\n</code></pre> <p>The execution will pause when <code>jiffies_64</code> changes.</p> <p>To analyse how <code>jiffies_64</code> is updated, use commands <code>info stack</code> or <code>backtrace</code> or <code>bt</code> to print the call stack.</p> <pre><code>(gdb) backtrace\n#0  do_timer (ticks=ticks@entry=1) at kernel/time/timekeeping.c:2429\n#1  0xffffffff8115e146 in tick_periodic (cpu=cpu@entry=0) at kernel/time/tick-common.c:95\n#2  0xffffffff8115e18f in tick_handle_periodic (dev=0xffff888003857400) at kernel/time/tick-common.c:113\n#3  0xffffffff81034ed3 in timer_interrupt (irq=&lt;optimized out&gt;, dev_id=&lt;optimized out&gt;) at arch/x86/kernel/time.c:39\n#4  0xffffffff8110c615 in __handle_irq_event_percpu (desc=desc@entry=0xffff888003861e00) at kernel/irq/handle.c:158\n#5  0xffffffff8110c7f3 in handle_irq_event_percpu (desc=0xffff888003861e00) at kernel/irq/handle.c:193\n#6  handle_irq_event (desc=desc@entry=0xffff888003861e00) at kernel/irq/handle.c:210\n#7  0xffffffff8111127b in handle_level_irq (desc=0xffff888003861e00) at kernel/irq/chip.c:648\n#8  0xffffffff81033a19 in generic_handle_irq_desc (desc=&lt;optimized out&gt;) at ./include/linux/irqdesc.h:173\n#9  handle_irq (regs=&lt;optimized out&gt;, desc=&lt;optimized out&gt;) at arch/x86/kernel/irq.c:247\n#10 call_irq_handler (regs=&lt;optimized out&gt;, vector=&lt;optimized out&gt;) at arch/x86/kernel/irq.c:259\n#11 __common_interrupt (regs=&lt;optimized out&gt;, vector=&lt;optimized out&gt;) at arch/x86/kernel/irq.c:285\n#12 0xffffffff81f740da in common_interrupt (regs=0xffffffff82a03db8, error_code=&lt;optimized out&gt;) at arch/x86/kernel/irq.c:278\nBacktrace stopped: Cannot access memory at address 0xffffc90000004010\n</code></pre> <p>The \"#0\" is the top of the stack, i.e. the current function. That is, <code>common_interrupt</code> function calls <code>__common_interrupt</code> function, which then calls a series of functions that eventually update <code>jiffies_64</code> in the <code>do_timer</code> function.</p> <p>If you look at the source code of <code>generic_handle_irq_desc</code> (#8) , you'll notice it invokes a method from <code>struct irq_desc</code>. The stack trace shows that the <code>handle_level_irq</code> (#7) function is called from here. This indicates that <code>handle_level_irq</code> is the method bound to <code>handle_irq</code> in this <code>struct irq_desc</code> instance.</p> <p>The stack trace shows that <code>handle_level_irq</code> is invoked with an argument <code>0xffff888003861e00</code>, which is the address of an <code>irq_desc</code> object. You can inspect this object in GDB:</p> <pre><code>(gdb) print *(struct irq_desc *)0xffff888003861e00\n</code></pre> <p>This command will interpret the memory contents at the specified address as a <code>irq_desc</code> object, allowing you to examine its properties.</p> <p>Question</p> <p>Which interrupt line (IRQ) is allocated for this specific interrupt?</p> <p>You might have encountered a warning indicating \"auto-loading has been declined\", it suggests that the script <code>vmlinux-gdb.py</code> provided by the kernel was not loaded successfully. This script offers a range of commands to streamline kernel debugging. For more information regarding this script, please refer to this page. Please solve the problem by following the instructions provided in the warning message.</p> <p>Now, let's start the kernel with an initial ramdisk so that it can properly switch to a user-space process. Please drop to a shell directly within the <code>init</code> process. You may follow the instructions from the previous assignment to create the initial ramdisk.</p> <pre><code>qemu-system-x86_64 -s -S -nographic -kernel ./arch/x86/boot/bzImage -append 'console=ttyS0 nokaslr' -initrd path/to/busybox.cpio.gz\n</code></pre> <p>There's a <code>user_mode_thread</code> function that is responsible for creating the first user-space process. It requires that the new thread shall executes the <code>kernel_init</code> function. Please set breakpoints properly and explore how the first user-space process is launched.</p> <p>Question</p> <p>How does the <code>/init</code> program get executed? Is this procedure similar to how <code>execve</code> works? Does a context switch occur, similar to what happens during a <code>syscall</code>? Please explain your observation briefly.</p>"},{"location":"asg2/task-module/","title":"Task 2: Developing a Kernel Module","text":"<p>A kernel module is a program that can be dynamically loaded and unloaded into the kernel on demand. This allows for the extension of kernel functionality without requiring the rebuilding of the kernel or system reboot.</p> <p>Numerous functionalities in the Linux kernel are implemented as modules. For instance, device drivers are commonly developed as modules. This modular approach enables the kernel to load only the necessary modules based on the hardware present in the system, effectively maintaining a compact kernel.</p> <p>In this task, we will explore some basic concepts of kernel module development and play with some essential APIs for kernel development.</p>"},{"location":"asg2/task-module/#say-hello-from-the-kernel","title":"Say Hello from the Kernel","text":"<p>Create a directory for your \"Hello World\" module.</p> <p>In the directory, create a file named \"hello.c\" with the following code to implement the \"Hello World\" module.</p> <pre><code>#include &lt;linux/init.h&gt;\n#include &lt;linux/module.h&gt;\n#include &lt;linux/printk.h&gt;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"cs5250\"); // Replace with your\nMODULE_DESCRIPTION(\"A sample kernel module\");\n\nstatic int __init hello_init(void)\n{\n    printk(KERN_NOTICE \"Hello World!\\n\");\n    pr_info(\"Hello, world!\\n\");\n    pr_debug(\"Greetings from %s.\\n\", THIS_MODULE-&gt;name);\n\n    return 0;\n}\n\nstatic void __exit hello_exit(void)\n{\n    pr_info(\"Goodbye world.\\n\");\n}\n\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n</code></pre> <p>Kernel modules must include at least two functions: an initialization function that is called when the module is loaded into the kernel and a cleanup function that is invoked just before the module is removed from the kernel. These functions are registered using the <code>module_init</code> and <code>module_exit</code> macros. Please locate the accurate definition (as used here) of the two macros within the kernel source code.</p> <p>Warning</p> <p>Make sure that you refer to the v6.13 version of the kernel source code.</p> <p>Question</p> <p>Identify the file and line number where the <code>module_init</code> macro is defined for our scenario.</p> <p>Please give your answer in the format <code>file#L1234</code>. For example, if it were defined in kernel/sched/core.c at line 6636, you should refer to it as <code>kernel/sched/core.c#L6636</code>.</p> <p>Upon loading the module, the <code>hello_init</code> function is executed, and within it, we print messages using <code>printk</code>. Typically, these messages include a priority level like <code>KERN_NOTICE</code>, <code>KERN_INFO</code> or <code>KERN_DEBUG</code>. In modern conventions, it is recommended to use print macros such as <code>pr_info</code> and <code>pr_debug</code> as alternatives to directly employing <code>printk</code>. These macros wrap around <code>printk</code>, keeping things the same while making code simpler and look nicer by cutting down on repetitive typing.</p> <p>Question</p> <p>Why is <code>printk</code> used instead of <code>printf</code> within kernel modules?</p> <p>To build the module, you need a Makefile. Please create a file named \"Makefile\" in the same directory as \"hello.c\" with the following content.</p> <pre><code>obj-m += hello.o\n\nall:\n    make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) modules\n\nclean:\n    make -C /lib/modules/$(shell uname -r)/build M=$(shell pwd) clean\n</code></pre> <p>Then run <code>make</code> to build the module. You should see a new file named \"hello.ko\" in the directory.</p> <p>To load the module, use the <code>insmod hello.ko</code> command. After loading the module, you can check the kernel log using the <code>dmesg</code> command to see the \"Hello World\" message. Then you can unload the module using the <code>rmmod hello</code> command.</p> <p>Question</p> <p>Did you observe the output \"Greetings from xxx\" when you loaded the module? If not, is this string compiled into the module? Provide a brief explanation of how to make the message at the \"DEBUG\" level appear in the kernel log.</p> <p>Hint: You might find the <code>strings</code> command helpful.</p>"},{"location":"asg2/task-module/#passing-arguments-to-a-module","title":"Passing Arguments to a Module","text":"<p>You can pass arguments to a module during its loading process by utilizing the <code>module_param</code> macro for declaring module parameters. Please search for further details on the usage of <code>module_param</code>, and modify the provided program below to declare two module parameters:</p> <ul> <li>A string parameter named \"<code>tag</code>\" with a default value corresponding to your Matriculation Number.</li> <li>An integer parameter named \"<code>pid</code>\" with a default value of 1.</li> </ul> <pre><code>#include &lt;linux/init.h&gt;\n#include &lt;linux/module.h&gt;\n#include &lt;linux/printk.h&gt;\n#include &lt;linux/sched.h&gt;\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"cs5250\");\nMODULE_DESCRIPTION(\"A sample kernel module\");\n\n/* MODIFY THE CODE BELOW TO declare module parameters */\nconst char *tag = \"A01234567A\";\npid_t pid       = 1;\n/* MODIFY THE CODE ABOVE TO declare module parameters */\n\nstatic int __init getcomm_init(void)\n{\n    pr_debug(\"This is %s speaking.\\n\", tag);\n\n    struct task_struct *task = get_pid_task(find_vpid(pid), PIDTYPE_PID);\n    pr_info(\"%s: [%d] %s\\n\", tag, task-&gt;pid, task-&gt;comm);\n\n    pr_debug(\"Goodbye from %s.\\n\", tag);\n    return 0;\n}\n\nstatic void __exit getcomm_exit(void)\n{\n    pr_info(\"Goodbye world.\\n\");\n}\n\nmodule_init(getcomm_init);\nmodule_exit(getcomm_exit);\n</code></pre> <p>Build the module and load it using the <code>insmod</code> command. You should observe an output in the kernel log similar to the following:</p> <pre><code>A01234567A: [1] systemd\n</code></pre> <p>Provide the <code>insmod</code> command with appropriate arguments to set the \"tag\" to <code>cs5250</code> and the \"pid\" to the PID of any valid process. The module should then print the tag, PID, and the executable name of the process in a similar format.</p> <p>Question</p> <p>Submit the source code for your kernel module. The module shall accept two parameters and output the process ID and executable name for the given PID. Ensure that the module compiles without errors using the Makefile and that it can be loaded and unloaded without any error.</p> <p>Question</p> <p>Submit the Makefile that builds and loads the kernel module. The Makefile should include two additional targets beyond those in the previously provided Makefile.</p> <ol> <li><code>insmod</code> loads the module with the appropriate arguments. The command that uses this target should be:    <pre><code>$ sudo make insmod tag=xxx pid=yyy\n</code></pre></li> <li><code>rmmod</code> unloads the module. The command that uses this target should be:    <pre><code>$ sudo make rmmod\n</code></pre></li> </ol>"},{"location":"asg2/task-syscall/","title":"Task 3: Creating a New System Call","text":"<p>Info</p> <p>For this task, you need to make modifications to the kernel source code and generate a patch. This process should be carried out within the Git repository of the kernel source code, based on version 6.13. Please consult the instructions provided in Assignment 1 for detailed guidance on cloning the Git repository.</p> <p>Danger</p> <p>If you are using the course-provided server, kindly perform this task within your VM. At no point should you attempt to install the kernel built by yourself directly in the server.</p>"},{"location":"asg2/task-syscall/#greetings-from-a-new-system-call","title":"Greetings from a New System Call","text":"<p>Generate a file named \"cs5250.c\" within the \"kernel/\" directory in your Linux source tree. Populate the file with the provided content. You have the flexibility to be creative with the printed message, but ensure to include your Matriculation Number.</p> <pre><code>#include &lt;linux/kernel.h&gt;\n#include &lt;linux/syscalls.h&gt;\n\nSYSCALL_DEFINE1(printmsg, int, i)\n{\n    pr_info(\"Hello! This is %d miles away from A0123456A\\n\", i);\n    return 1;\n}\n</code></pre> <p>The <code>SYSCALL_DEFINE1</code> macro is defined in \"syscalls.h\". It expands into the function definition and additional facilities for kernel debugging. The suffix \"1\" signifies that the function takes one argument. For a syscall function with two parameters, use <code>SYSCALL_DEFINE2</code>.</p> <p>Add the line <code>obj-y += cs5250.o</code> to the \"Makefile\" in the \"kernel/\" directory. This ensures that the kernel includes your new program in the kernel image.</p> <p>Find the table of function entries (Hint: it starts with \"syscall\") and append your function as a new entry at the end of the table.</p> <p>Recompile the kernel and boot into the new kernel.</p>"},{"location":"asg2/task-syscall/#invoking-the-new-system-call","title":"Invoking the New System Call","text":"<p>To create a user-mode program that invokes your custom kernel function, here's a sample program template. Make sure to replace <code>&lt;the_index&gt;</code> with the syscall number you were assigned for your custom system call during the previous steps.</p> <pre><code>#include &lt;unistd.h&gt;\n#include &lt;sys/syscall.h&gt;\n\n// Replace &lt;the_index&gt; with your custom system call's actual syscall number.\n#define __NR_printmsg &lt;the_index&gt;\n\nint printmsg(int i) {\n    // Invoke your custom system call using syscall.\n    return syscall(__NR_printmsg, i);\n}\n\nint main(int argc, char **argv) {\n    // Use the custom system call with an example argument, such as 668.\n    printmsg(668);\n    return 0;\n}\n</code></pre> <p>After updating your program with the correct syscall number, compile and run it to trigger your custom system call. Use <code>dmesg</code> to check the outputs and confirm its execution.</p>"},{"location":"asg2/task-syscall/#finding-children","title":"Finding Children","text":"<p>The Linux kernel extensively employs linked lists. The <code>struct task_struct</code> in the Linux kernel includes a <code>children</code> member, a <code>struct list_head</code> representing the head of a linked list of all child processes of a given process.</p> <p>You will implement a new system call, <code>getcpid</code>, that provides a mechanism to obtain the PIDs of child processes for a given parent process.</p> <p>In \"cs5250.c\", define the <code>getcpid</code> system call with the following signature:</p> <pre><code>ssize_t getcpid(pid_t pid, pid_t *cpid, uint32_t count);\n</code></pre> <p>The <code>getcpid</code> system call should take three arguments:</p> <ul> <li><code>pid</code>: The process ID of the parent process whose child PIDs are to be retrieved.</li> <li><code>cpid</code>: A pointer to a user-space array where the child PIDs will be stored.</li> <li><code>count</code>: The size of the <code>cpid</code> array in number of elements.</li> </ul> <p>When <code>cpid</code> is non-<code>NULL</code>, up to <code>count</code> child PIDs are stored in the array pointed to by <code>cpid</code>. If cpid is <code>NULL</code>, the system call returns the total number of child processes without storing any PIDs.</p> <p>RETURN VALUE:</p> <ul> <li>If cpid is <code>NULL</code>, the total number of child processes is returned.</li> <li>Otherwise:<ul> <li>On success, the number of child PIDs stored in the <code>cpid</code> array is returned.</li> <li>On error, <code>-1</code> is returned, and <code>errno</code> is set appropriately.</li> </ul> </li> </ul> <p>ERRORS:</p> <ul> <li><code>ESRCH</code>: No process with the specified PID exists.</li> <li><code>EINVAL</code>: The <code>count</code> parameter is less than the number of child processes, or <code>cpid</code> is <code>NULL</code> and <code>count</code> is not zero.</li> <li><code>EFAULT</code>: The <code>cpid</code> pointer points outside the accessible address space.</li> </ul> <p>You are not required to strictly adhere to the \"return value\" and \"error\" specifications. The key requirement here is that the system call must not assume the number of child processes is limited to 10, 20, 1024, or similar small values. You may assume it is smaller than 0x400000, but allocating a buffer of that size every time the system call is invoked is not a good idea.</p> <p>For guidance on how the system call should behave, you may look at the interface of <code>getdents</code>.</p> <p>Warning</p> <p>You MUST use <code>put_user</code>, <code>get_user</code>, <code>copy_to_user</code>, or <code>copy_from_user</code> to safely read from or write to user-space memory. Directly accessing user-space memory from the kernel is NOT allowed.</p> <p>Modern x86 processors implement Supervisor Mode Access Prevention (SMAP), a security feature that restricts the kernel from accessing user-space memory directly. Attempting such access without the appropriate functions will result in a fault.</p> <p>The functions <code>put_user</code>, <code>get_user</code>, <code>copy_to_user</code>, and <code>copy_from_user</code> help to handle user-space memory access safely. They temporarily disable SMAP protections during the memory access operation and restore them immediately afterward, ensuring both functionality and security are maintained. These functions also perform essential checks to ensure the safety and validity of memory access.</p> <p>See: https://www.kernel.org/doc/html/v6.13/kernel-hacking/hacking.html#copy-to-user-copy-from-user-get-user-put-user</p> <p>Additionally, create a user-mode program that uses your custom kernel function. This program should take the PID of a process as input and output the PIDs of all its children, one per line.</p>"},{"location":"asg2/task-syscall/#contribute-to-the-kernel","title":"\"Contribute\" to the Kernel","text":"<p>Please commit your changes and create a patch file<sup>1</sup> that includes all essential changes related to the implementation of the new system call, using <code>git format-patch</code> command. For guidance and reference, check the Git documentation and the Kernel documentation.</p> <p>Please adhere to the following guidelines for your submission:</p> <ol> <li>Make sure your patch can be successfully applied to a clean clone of the kernel source tree, at version 6.13.    If the patch fails to apply, this will lead to a score of zero for this task.</li> <li>Ensure that the kernel compiles successfully after your patch is applied.    Failure to compile the kernel will also result in a score of zero for this task.</li> <li>Your patch must contain only the essential changes to the kernel source code required for implementing the new system call.    Any deviation from this requirement will incur a penalty.</li> <li>If your work results in multiple commits, please be aware that each commit corresponds to a separate patch file.    You are required to combine these commits into a single commit and then generate a single patch file that includes all changes.</li> </ol> <p>Question</p> <p>Please provide the patch file for the changes you made to the kernel source code to create the new system call.</p> <ul> <li>The patch file must be able to be applied to the v6.13 version of the kernel source code without any errors.   If the patch file cannot be applied, you will receive zero marks for this question.</li> <li>The patched kernel must be able to compile without any errors.   If the patched kernel cannot compile, you will receive zero marks for this question.</li> </ul> <p>Question</p> <p>Please provide the source code for your user-mode program in a C file. This program should take the PID of a process as input, invoke the new system call you created, and output the PIDs of all its children, one per line. Please ensure that the program compiles without error.</p> <ol> <li> <p>This submission format is designed to offer an initial experience in the process of contributing to the Linux kernel. In future contributions to the Linux kernel, it will be imperative to generate a patch file including your changes and submit it for review to the community's mailing list. The intention is not to challenge your proficiency in using Git, and it's not divergent from the primary goals of this course.\u00a0\u21a9</p> </li> </ol>"},{"location":"asg3/","title":"Introduction","text":"<p>Info</p> <p>Please read the general instructions first.</p> <p>The assignment is due 17:59 on 31 Mar 2025. If the \"Memory Management\" lecture has not been completed by this date, the deadline will be extended to 17:59 on the following Monday after that lecture. Please refer to the due date set on Canvas for the most up-to-date deadline. No further announcements will be made regarding the extension if it occurs.</p> <p>Late submissions will lose 1 mark per hour.</p> <p>If you discover any errors or need any clarification or have any question, please create an issue here.</p>"},{"location":"asg3/#part-a-35-marks","title":"Part A (35 marks)","text":"<p>Note</p> <p>In this assignment, we will look at how to hack a game of Tetris by hooking system calls and manipulating memory.</p> <p>Please accept the assignment on GitHub Classroom. The executable <code>tetris</code> is provided in the repository. You can verify the integrity of the provided <code>tetris</code> binary by checking its SHA-1 hash. <pre><code>$ sha1sum tetris\n69a36d6731f41330f38803e4f6b349c2bf5c4f42  tetris\n</code></pre></p> <p>The executable is a statically linked AMD64 ELF binary. It should execute without any problems on your Ubuntu system. If there's any trouble executing the binary, please report here.</p>"},{"location":"asg3/#task-1-hook-system-calls-with-kprobes","title":"Task 1: Hook System Calls with KProbes","text":"<p>Question 1 (1 marks): What is the name of the system call that the game uses to keep track of time?</p> <p>Question 2 (2 marks): Give the complete command to run <code>strace</code> so that:</p> <ul> <li>The output is written to a file.</li> <li>Only the system call that the game uses to keep track of time is shown.</li> <li>It's fine if there are some other outputs not related to system calls, e.g., information about signals or exit status.</li> </ul> <p>Question 3 (5 marks): In the module, the first argument of the system call is accessed using <code>((struct pt_regs *)(regs-&gt;di))-&gt;di</code>. Why do we need such an indirection to retrieve the arguments of the system call instead of directly accessing <code>regs-&gt;di</code>? Please explain with a brief description of the call trace.</p> <p>Question 4 (2 marks): What is the problem with the address of the system call service routine? How can you fix this problem and print the real address of the system call service routine?</p> <p>Question 5 (2 marks): Please fix this problem and print the real address of the system call service routine. This should be a one-line change in the kernel module.</p> <p>Question 6 (2 marks): What is the GDB command to print the entry in the syscall table for the system call you identified in Question 1?</p> <p>Question 7 (6 marks): Please modify the provided kernel module to delay the movement of the bricks in the <code>tetris</code> game by 1 second.</p>"},{"location":"asg3/#task-2-memory-manipulation-in-tetris-game","title":"Task 2: Memory Manipulation in Tetris Game","text":"<p>Question 8 (5 marks): In which memory regions is it likely that the score is stored?</p> <ol> <li>Provide a complete copy of the output of <code>/proc/[pid]/maps</code> for the <code>tetris</code> process.</li> <li>List the memory regions that you believe are probable candidates for storing the score.</li> <li>Explain your rationale for why these memory regions are more likely to contain the score than others.</li> </ol> <p>Question 9 (6 marks): Please submit the source code of the program written in either C++ or Python.</p> <p>Question 10 (4 marks): Please discuss security concern with a LLM such as ChatGPT. Ask if there are any methods to prevent such unwanted actions. Evaluate the provided response for its effectiveness. If multiple solutions are suggested, choose ONLY one of them to discuss.</p>"},{"location":"asg3/#submission-guidelines","title":"Submission Guidelines","text":"<p>Please accept the assignment on GitHub Classroom first. The invitation link is available on Canvas. Then, proceed to complete the tasks and push your work to GitHub accordingly.</p> <p>Refer to the submission guidelines in Assignment 1 for the remaining instructions.</p> <p>For this assignment:</p> <ol> <li>Questions 1, 2 and 6 shall be answered in the <code>manifest.json</code> file directly.</li> <li>Question 9 can be answered either in C++ or Python. Please update the entry in <code>manifest.json</code> accordingly.</li> </ol>"},{"location":"asg3/#part-b-15-marks","title":"Part B (15 marks)","text":"<p>Please complete the quiz Assignment 3 (Part B) on Canvas.</p>"},{"location":"asg3/task-kprobe/","title":"Task 1: Hook System Calls with KProbes","text":"<p>Before beginning, download and execute the <code>tetris</code> binary and get familiarized with the game.</p>"},{"location":"asg3/task-kprobe/#how-time-flies","title":"How Time Flies","text":"<p>In this game, the bricks fall from the top of the screen by one row at a specific time interval. As you can imagine, there should be some mechanism to keep track of time and trigger the movement of the bricks. This can be achieved in generally two ways: One approach is to invoke a <code>sleep</code> system call to pause execution for the desired interval, then move the bricks when the process resumes. Another approach is to set up a timer and registers a callback function to execute when the timer expires, and move the bricks in the callback function.</p> <p>Since both methods require the use of system calls, let's use <code>strace</code> to observe how the game tracks time. We can get an initial idea of <code>strace</code> by running the following command:</p> <pre><code>strace cat /dev/null\n</code></pre> <p>A list of system calls made by the <code>cat</code> command, together with their arguments and return values, will be printed. However, if we run <code>strace ./tetris</code> directly, the output will be corrupted due to interleaved output both from the game and <code>strace</code>. It would be helpful to write the output of <code>strace</code> to a file and inspect it later.</p> <pre><code>strace -o &lt;filename&gt; ./tetris\n</code></pre> <p>Give a filename of your choice to the <code>-o</code> option, execute the command, and enjoy the game for a while. Then press <code>q</code> to quit the game and inspect the output file.</p> <p>Question</p> <p>What is the name of the system call that the game uses to keep track of time?</p> <p>Please read the man page of the system call, or ask ChatGPT if you need, to learn how to use it. Write a small program to demonstrate the use of the system call. (The program will be used to test the hooking mechanism later.)</p> <p>The <code>strace</code> outputs many system calls. To facilitate the analysis, some flag can be used to filter the output. Read the man page of <code>strace</code> to find the flag that can be used to filter the output of <code>strace</code> to only show the system call you identified in the previous question.</p> <p>Question</p> <p>Give the complete command to run <code>strace</code> so that:</p> <ul> <li>The output is written to a file.</li> <li>Only the system call that the game uses to keep track of time is shown.</li> <li>It's fine if there are some other outputs not related to system calls, e.g., information about signals or exit status.</li> </ul>"},{"location":"asg3/task-kprobe/#wait-its-too-fast","title":"Wait! It's Too fast!","text":"<p>Now that you have identified the system call the game uses to track time, let\u2019s see if we can slow things down, giving you more time to make decisions. Whether the game uses a sleep or a timer, the timing is always kept track of by the kernel. That means the kernel either returns from the system call after a set duration or sends a signal to the process when the timer expires. By intercepting this system call, we can tweak its arguments to extend the duration before the bricks move, effectively slowing down the game.</p> <p>To achieve this, we'll employ a kernel feature known as KProbes. KProbes allows inserting a probe at a specific kernel address and registering a callback function to be invoked when the probe is hit. This callback function can modify the arguments and return value of the probed function, or even bypass the system call and return directly to the caller.</p>"},{"location":"asg3/task-kprobe/#a-first-glance-at-kprobes","title":"A First Glance at KProbes","text":"<p>KProbe is implemented as a kernel module. A simple example of a kernel module using KProbes is provided in the repository in the \"task1/hook\" directory. This module intercepts the <code>__do_sys_ni_syscall</code> system call service routine and prints its arguments.</p> <p>Lines 26-28 of the code implement a simple filter, ensuring the probe triggers only when the <code>current</code> process has a <code>comm</code> field matching the specified string argument <code>comm</code>. When loading the module, you should provide an appropriate value to the <code>comm</code> argument to ensure the probe triggers only when the intended program is running.</p> <p>Here's a user program that invokes <code>__do_sys_ni_syscall</code>.</p> <pre><code>#include &lt;unistd.h&gt;\n\nint main()\n{\n    syscall(423, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60);\n    return 0;\n}\n</code></pre> <p>After building and loading the kernel module, execute the user program. Then inspect the kernel log to observe the output of the kernel module. You will find the arguments passed to <code>__do_sys_ni_syscall</code> there.</p> <pre><code>hook: --- [[ Module loaded ]] ---\nhook: intercepted [20092] test\nhook: pre_handler: __do_sys_ni_syscall@00000000243ec603\nhook: rdi = 0x10\nhook: rsi = 0x20\nhook: rdx = 0x30\nhook: r10 = 0x40\nhook: r8  = 0x50\nhook: r9  = 0x60\nhook: --- [[ Module unloaded ]] ---\n</code></pre> <p>Question</p> <p>In the module, the first argument of the system call is accessed using <code>((struct pt_regs *)(regs-&gt;di))-&gt;di</code>. Why do we need such an indirection to retrieve the arguments of the system call instead of directly accessing <code>regs-&gt;di</code>? Please explain with a brief description of the call trace.</p> <p>Hint: https://www.kernel.org/doc/html/v6.13/trace/kprobes.html#how-does-a-kprobe-work</p> <p>Take note of the address of the system call service routine. You may find that it does not fall within the region of the \"kernel text\", as indicated in the memory layout documentation. Why is this the case? How can you fix this problem?</p> <p>Question</p> <p>What is the problem with the address of the system call service routine? How can you fix this problem and print the real address of the system call service routine?</p> <p>Hint: https://www.kernel.org/doc/html/v6.13/core-api/printk-formats.html</p> <p>Question</p> <p>Please fix this problem and print the real address of the system call service routine. This should be a one-line change in the kernel module.</p>"},{"location":"asg3/task-kprobe/#find-the-hook-point","title":"Find the Hook Point","text":"<p>To hook the system call, you need to find the symbol name of the service routine implementing the system call. You've done this in Pop Quiz 6, and you can do it again. However, with the <code>vmlinux</code> file available, you can use <code>gdb</code> to find the symbol name of the service routine.</p> <pre><code>$ gdb vmlinux\n\n&lt;some output omitted here&gt;\n\n(gdb) print sys_call_table\n$1 = {...}\n</code></pre> <p>This command prints the contents of the <code>sys_call_table</code> variable, which is a lengthy array of function pointers. To locate the symbol name of the service routine, you can look up the syscall table to find the syscall number of the system call, and then print only that entry in the syscall table.</p> <p>Question</p> <p>What is the GDB command to print the entry in the syscall table for the system call you identified in Question 1?</p> <p>Having identified the symbol name of the service routine, you can proceed to modify the kernel module to hook the desired system call. After modifying the kernel module, build it and load it into the kernel. In a previous step, you wrote a small program to demonstrate the use of the system call. Now, execute the program and review the kernel log to observe the output.</p> <p>Now that we've successfully hooked the system call and accessed its arguments, we can modify them to extend the time before the bricks move again.</p> <p>However, it might not be as simple as it seems to hook at the very beginning of the system call service routine. One important argument is passed as a pointer to a user-space address. Directly modifying this value in user space might trigger the game's cheat detection system, causing it to refuse execution. To avoid this, it would be better to modify the value in kernel space. But the control flow, after the pre-handler is executed, will return to the original service routine. The original service routine assumes that the pointer still references a valid user-space address. If the pointer instead references a kernel-space address, the original service routine could crash.</p> <p>Let's find a workaround.</p> <p>Locate the system call definition in the kernel source code and examine how it handles the arguments. Can you identify another function to hook, where the important argument is already in kernel space?</p> <p>Question</p> <p>Modify the kernel module to:</p> <ul> <li>Hook the new function you found.</li> <li>Increment the duration by one second. (Not \"to\" one second.)</li> <li>Adjust the <code>MODULE_AUTHOR</code> to your name.</li> </ul> <p>After loading the kernel module, run the game and observe if the time flows slower.</p>"},{"location":"asg3/task-memhack/","title":"Task 2: Memory Manipulation in Tetris Game","text":"<p>Note</p> <p>In this task, you'll be using the same <code>tetris</code> binary as in Task 1.</p> <p>The game might not hold much appeal, but I'm eager to impress my friends with an incredibly high score. Let's surprise them by modifying the score in the game.</p> <p>The score is stored as a <code>int32_t</code> variable in memory. We'll locate the address of the score and update it to a large number.</p>"},{"location":"asg3/task-memhack/#memory-regions","title":"Memory Regions","text":"<p>In order to modify the score, we need to find the address of the score in the <code>tetris</code> process.</p> <p>The memory regions mapped to a process can be found in <code>/proc/[pid]/maps</code>. For instance, to view the memory regions of the <code>bash</code> process:</p> <pre><code>$ pgrep bash\n769525\n$ cat /proc/769525/maps\n&lt;output omitted here&gt;\n</code></pre> <p>Please check the manual page of <code>proc</code> for the meaning of the columns.</p> <p>Run the <code>tetris</code> game and pause it. Find its process ID using the <code>ps</code> or <code>pgrep</code> command. Then, print the memory regions of the <code>tetris</code> process.</p> <p>Question</p> <p>In which memory regions is it likely that the score is stored?</p> <ol> <li>Provide a complete copy of the output of <code>/proc/[pid]/maps</code> for the <code>tetris</code> process.</li> <li>List the memory regions that you believe are probable candidates for storing the score.</li> <li>Explain your rationale for why these memory regions are more likely to contain the score than others.</li> </ol>"},{"location":"asg3/task-memhack/#hack-into-the-memory-space","title":"Hack into the Memory Space","text":"<p>Merely identifying suspicious memory regions isn't sufficient. We need to locate the exact address of the score in the <code>tetris</code> process.</p> <p>To find the exact address of the score in the <code>tetris</code> process, we can play the game for a while, pause it, and then search through these regions for the score value. If a 4-byte word in a memory region matches the score value, it's likely where the score is stored. This involves digging into the <code>tetris</code> process's virtual memory to gather the necessary information.</p> <p>Under procfs, there's a file <code>/proc/[pid]/mem</code> that allows you to read and write to the virtual memory of a process. Please refer to the man page of <code>proc</code> and read the section about <code>/proc/[pid]/mem</code>. No need to worry about permission issues in this task. You can use <code>sudo</code> to read and write to <code>/proc/[pid]/mem</code>.</p> <p>A demo is provided in the \"task2/demo\" folder to help you understand how to hack into the virtual memory of a process via <code>/proc/[pid]/mem</code>.</p> <p>Please write a C++ program or a Python script to locate the address of the score in the <code>tetris</code> process. The program should accept a single command-line argument, which is the process ID of the <code>tetris</code> process.</p> <p>The program should first read the <code>maps</code> file of the <code>tetris</code> process to determine the potential memory ranges where the score might be stored. Then, it should read the score value from stdin, and scan through the identified memory regions to locate the score value. If it finds a memory location holding the score value, it should print out the address of that memory location.</p> <p>It's possible that within these regions, there are multiple words containing the same value as the score. To eliminate false positives, you can continue playing the game and pause it again to observe how these words change. If you find memory locations that don't change as expected when the score updates, you can exclude them from consideration and finally find the actual address of the score.</p>"},{"location":"asg3/task-memhack/#change-the-score","title":"Change the Score","text":"<p>Now that you have determined the address of the score, you can proceed to modify it to a larger number. Please update your program so that it can write a new score to the memory location of the score in the <code>tetris</code> process.</p> <p>Warning</p> <p>Please note: any compilation errors, syntax errors, or runtime errors will result in a score of 0 for this task.</p> <p>You should probe the address of the score in your program interactively. It's not allowed to hardcode the address of the score in your program. A different victim program will be used to test your program, so the address will be different from the one in this tetris game.</p> <p>Question</p> <p>Please submit the source code of the program written in either C++ or Python. Please remove the other source code file from the repository, and update the \"manifest.json\" file accordingly before submission.</p>"},{"location":"asg3/task-memhack/#im-so-scared","title":"I'm So Scared!","text":"<p>In this task, we demonstrated how a root user can read and write to the virtual memory of a process running on the system, posing a security risk. If you are using a shared system like the SoC Compute Cluster, the system administrator might potentially access your process and extract sensitive runtime information as well.</p> <p>Question</p> <p>Please discuss security concern with a LLM such as ChatGPT. Ask if there are any methods to prevent such unwanted actions. Evaluate the provided response for its effectiveness. If multiple solutions are suggested, choose only ONE of them to discuss.</p>"},{"location":"asg4/","title":"Introduction","text":"<p>Info</p> <p>Please read the general instructions first.</p> <p>The assignment is due 17:59 on 21 Apr 2025. Late submissions will lose 1 mark per hour.</p> <p>If you discover any errors or need any clarification or have any question, please create an issue here.</p>"},{"location":"asg4/#part-a-35-marks","title":"Part A (35 marks)","text":"<p>Note</p> <p>Please accept the assignment on GitHub Classroom first. The invitation link is available on Canvas.</p>"},{"location":"asg4/#task-0-cloud-init","title":"Task 0: Cloud-Init","text":""},{"location":"asg4/#task-1-pci-device","title":"Task 1: PCI Device","text":"<p>Question 1 (2 marks)</p> <p>Take a screenshot of the <code>lspci</code> command and its output that shows the name of the slot where the device resides. Highlight the entry relevant to the EDU device device you are emulating.</p> <p>Please adjust the terminal width to 80-120 characters when you take the screenshot, so that the screenshot is easily readable.</p> <p>Question 2 (4 marks)</p> <p>Why can't we read from the file <code>resource0</code>?</p> <p>Question 3 (5 marks)</p> <p>Please write a C program that operates the <code>resource0</code> of the PCI device by mapping it into the process's address space.</p>"},{"location":"asg4/#task-2-character-device-driver-and-ioctl","title":"Task 2: Character Device Driver and <code>ioctl</code>","text":"<p>Question 4 (4 marks)</p> <p>Please finish the implementation of the <code>edu_ioctl</code> function in the file: <code>task2/edu-ioctl/edu.c</code></p> <p>Question 5 (2 marks)</p> <p>Please write a C program that interacts with the character device driver using ioctl.</p>"},{"location":"asg4/#task-3-interrupt-handler","title":"Task 3: Interrupt handler","text":"<p>Question 6 (18 marks)</p> <p>Please finish the implementation under the directory <code>task3/edu-irq/</code> in the repository.</p>"},{"location":"asg4/#submission-guidelines","title":"Submission Guidelines","text":"<p>Please accept the assignment on GitHub Classroom first. The invitation link is available on Canvas. Then, proceed to complete the tasks and push your work to GitHub accordingly.</p> <p>Refer to the submission guidelines in Assignment 1 for the remaining instructions.</p>"},{"location":"asg4/#part-b-15-marks","title":"Part B (15 marks)","text":"<p>Please complete the quiz Assignment 4 (Part B) on Canvas.</p>"},{"location":"asg4/task-chardev/","title":"Task 2: Character Device Driver and <code>ioctl</code>","text":"<p>In this task, you will implement a character device driver for the dummy EDU device.</p> <p>Please read the following sections of The Linux Kernel Module Programming Guide:</p> <ul> <li>Section 5.6 \u2013 Device Drivers</li> <li>Section 6 \u2013 Character Device Drivers</li> <li>Section 9 \u2013 Talking to Device Files</li> </ul> <p>Note</p> <p>There is a mistake in the guide regarding the direction of <code>ioctl</code> operations: \"Write\" and \"read\" are from the user's point of view, just like the system calls <code>write</code> and <code>read</code>.</p> <ul> <li>A <code>SET_FOO</code> ioctl should use <code>_IOW</code>, even though the kernel is reading data from user space.</li> <li>A <code>GET_FOO</code> ioctl should use <code>_IOR</code>, even though the kernel is writing data to user space.</li> </ul> <p>The material above explains how a userspace program may interact with a device driver, but it does not clearly show how the driver itself communicates with the PCI device hardware.</p> <p>Similar to our previous task, the PCI device is identified using its vendor ID and device ID. The kernel\u2019s PCI subsystem locates the device and invokes the <code>probe</code> callback function defined in the driver.</p> <p>The <code>probe</code> function is responsible for initializing the device and setting up the driver to manage communication with it. Once this setup is complete, the driver either enumerates the device\u2019s resources or accesses known, pre-defined ones directly.</p> <p>From that point on, the driver communicates with the hardware according to the device\u2019s specification, typically through memory-mapped I/O or port I/O, allowing the system to use the device.</p> <p>Please walk through the code provided in the <code>task2/edu-ioctl</code> directory, and complete the implementation of the <code>edu_ioctl</code> function. Your implementation should handle the following <code>ioctl</code> commands:</p> <ul> <li><code>IOCTL_EDU_IDENT</code>: Read the device identification register and return it to user space.</li> <li><code>IOCTL_EDU_LIVECHECK</code>: Perform a liveness check (e.g., invert the given number and return the result).</li> </ul> <p>Question</p> <p>Please finish the implementation of the <code>edu_ioctl</code> function in the file: <code>task2/edu-ioctl/edu.c</code></p> <p>You will also write a user-space program that interacts with the character device driver using <code>ioctl</code> to test the device driver. The user-space program should accept two arguments:</p> <ol> <li>The path to the character device file (e.g., <code>/dev/edu0</code>).</li> <li>A 32-bit unsigned integer in hexadecimal format.</li> </ol> <p>The program should output the device identification and the bitwise inversion of the given number using <code>ioctl</code>. Here's the expected behavior of the program:</p> <pre><code>$ sudo ./test-ioctl /dev/eduX 0x11111111\nIdentification: 0x010000edu\n     Inversion: 0xeeeeeeee\n</code></pre> <p>Question</p> <p>Please write a C program that interacts with the character device driver using ioctl.</p>"},{"location":"asg4/task-cloudinit/","title":"Task 0: Cloud-Init","text":"<p>In this assignment, we'll use QEMU to emulate a non-existent peripheral device and develop a device driver for it. But before diving into that, let's establish a production-level virtual machine using QEMU, transitioning away from a testing environment.</p>"},{"location":"asg4/task-cloudinit/#step-1-boot-using-a-cloud-image","title":"Step 1: Boot Using a Cloud Image","text":"<p>In Assignment 1, we used a RootFS archive to create a disk image, which didn\u2019t include any boot components. This time, we\u2019ll boot from a cloud image, which is a full disk image that includes a bootable operating system.</p> <p>Download the Ubuntu 24.04 cloud image https://cloud-images.ubuntu.com/releases/24.04/release/ubuntu-24.04-server-cloudimg-amd64.img.</p> <p>We can directly boot from this image, but doing so would modify it, which we want to avoid. In a real cloud environment, the same base image is used to spin up many virtual machines. To keep it reusable, we avoid writing to it by creating a new disk image backed by the cloud image. This keeps the base image untouched and stores all changes in a separate overlay file.</p> <pre><code>qemu-img create -f qcow2 -b ubuntu-24.04-server-cloudimg-amd64.img -F qcow2 cs5250-asg4.qcow2 16G\n</code></pre> <p>Then, you can boot the image using the following command:</p> <pre><code>qemu-system-x86_64 -nographic -smp 2 -m 2G cs5250-asg4.qcow2\n</code></pre> <p>Here, the <code>-smp</code> option specifies the number of virtual CPU cores, and the <code>-m</code> option specifies the amount of memory. You can adjust these values based on the resources available on your machine.</p>"},{"location":"asg4/task-cloudinit/#step-2-customize-your-vm-using-cloud-init","title":"Step 2: Customize Your VM Using Cloud-Init","text":"<p>You might have tried logging into the VM but failed, because you don't know the credentials to log in. This is similar to what we encountered in Assignment 1, where the VM also didn't have a user created by default. So before logging in, we need to create one.</p> <p>Previously, we handled this by booting into single-user mode and manually adding a user. While that works, it\u2019s not scalable. In real-world scenarios, especially in cloud environments, we need a more automated way to set up VMs. Here we'll use cloud-init, a tool designed to automate the initial setup of cloud VMs. It can create users, set passwords or SSH keys, install packages, and much more. Let's follow the documentation.</p> <p>Create a file named <code>user-data</code> with the following content: (make sure to replace the username and password with your own)</p> <pre><code>#cloud-config\nhostname: cs5250-asg4\nusers:\n  - name: ubuntu\n    plain_text_passwd: password\n    lock_passwd: false\n    groups: users, admin\n    sudo: ALL=(ALL) NOPASSWD:ALL\n    shell: /bin/bash\nssh_pwauth: true\n</code></pre> <p>This file tells cloud-init what configuration to apply on first boot:</p> <ul> <li>Creates a user <code>ubuntu</code> with the password <code>password</code></li> <li>Enables password-based SSH login</li> <li>Grants the user full <code>sudo</code> access</li> </ul> <p>There are multiple ways for cloud-init to receive configuration data. For simplicity, we\u2019ll use a seed ISO image.</p> <pre><code>cloud-localds seed.img user-data\n</code></pre> <p>This creates an ISO image containing the configuration. It acts like a virtual \"cloud config drive\".</p> <p>Now boot the VM again, this time attaching the seed image as a CD-ROM:</p> <pre><code>qemu-system-x86_64 -nographic -smp 2 -m 2048 -nic user \\\n  -drive media=cdrom,format=raw,file=seed.img \\\n  -drive media=disk,format=qcow2,file=cs5250-asg4.qcow2\n</code></pre> <ul> <li><code>-nic user</code>: Provides basic user-mode networking</li> <li><code>-drive media=cdrom</code>: Attaches the config ISO as a virtual CD</li> <li><code>-drive media=disk</code>: Attaches the disk image</li> </ul> <p>During boot, you\u2019ll see logs from <code>cloud-init</code>. Eventually, it should say:</p> <pre><code>Cloud-init ... finished at ...\n</code></pre> <p>Press Enter to get to the login prompt. You can now log in using the username and password you configured earlier.</p>"},{"location":"asg4/task-cloudinit/#step-3-ssh-into-the-vm","title":"Step 3: SSH into the VM","text":"<p>While the QEMU console works, it can be finicky. For instance, there\u2019s no line editing, so using backspace may behave weirdly. It's not ideal for scripting or prolonged interaction.</p> <p>To improve the workflow, you can forward the SSH port from the host to the VM. Update your boot command like this:</p> <pre><code>qemu-system-x86_64 -nographic -smp 2 -m 2048 \\\n  -nic user,hostfwd=tcp::2222-:22 \\\n  -drive media=cdrom,format=raw,file=seed.img \\\n  -drive media=disk,format=qcow2,file=cs5250-asg4.qcow2\n</code></pre> <ul> <li><code>hostfwd=tcp::2222-:22</code> maps port 2222 on your host to port 22 (SSH) on the guest</li> </ul> <p>Now you can SSH into the VM from the host:</p> <pre><code>ssh &lt;username&gt;@localhost -p 2222\n</code></pre> <p>You can change the port number <code>2222</code> to any other port number you prefer.</p>"},{"location":"asg4/task-interrupt/","title":"Task 3: Interrupt handler","text":"<p>Note</p> <p>You're to use the same environment as in the previous task.</p> <p>The PCI device we're dealing with in this task can calculate the factorial of a number. When the computation completes, the device raises an interrupt if the status register is set correctly.</p> <p>In this task, we've provided you with framework code for the device driver. Your job is to implement the interrupt handler and the service routines (open, close, read, and write) of the character device.</p> <p>Here's the specification:</p> <ul> <li>(2 marks)   The device file must only be opened with either <code>O_WRONLY</code> or <code>O_RDONLY</code>.   Opening with both or other flags should return <code>-EINVAL</code>.</li> <li>(2 marks)   The device file can only be opened at most once at any time.   If the device file is already opened, the handler should return <code>-EBUSY</code> when another open attempt is made.</li> <li>(3 marks)   If the file is opened with the <code>O_WRONLY</code> flag, you can then write a number to the device file.   The correctness of the write function is checked based on whether the \"edu\" device receives the expected input when the file is closed.</li> <li>(3 marks)   If the file is opened with the <code>O_RDONLY</code> flag, you can then read the result of the factorial calculation.   The correctness of the read function is checked by strict string matching between the output of the read function and the expected output described in the example below.</li> <li>(2 marks)   The \"edu\" device shall start calculating the factorial when the file is closed, provided it was opened with the <code>O_WRONLY</code> flag and a number was written to it.</li> <li>(2 marks)   While the device is calculating the factorial, the device file cannot be opened until the computation is finished.   If the device file is opened while the device is calculating the factorial, the handler should return <code>-EBUSY</code>.</li> <li>(4 marks)   The driver must rely on the interrupt to be notified that the calculation is finished.   Polling to check if the calculation is finished is not allowed.</li> </ul> <p>Your driver must be free of memory errors. Deadlock should not occur in the driver under any circumstances.</p> <p>The following examples illustrate the expected behavior of the device. These examples are for demonstration only; we will use different input values for grading.</p> <pre><code>$ sudo insmod edu.ko\n$ echo 1 | sudo tee /dev/edu0\n1\n$ sudo cat /dev/edu0\nfact(1) = 1\n$ echo 5 | sudo tee /dev/edu0\n5\n$ sudo cat /dev/edu0\nfact(5) = 120\n$ echo x | sudo tee /dev/edu0\nx\n$ sudo cat /dev/edu0\nfact(5) = 120\n$ echo 12 &gt; tmp.in\n$ sudo dd if=tmp.in of=/dev/edu0 bs=1\n3+0 records in\n3+0 records out\n3 bytes copied, 4.9727e-05 s, 60.3 kB/s\n$ sudo dd if=/dev/edu0 of=tmp.out bs=1\n21+0 records in\n21+0 records out\n21 bytes copied, 0.00015907 s, 132 kB/s\n$ sudo cat tmp.out\nfact(12) = 479001600\n$ sudo rmmod edu\n</code></pre> <p>Question</p> <p>Please finish the implementation under the directory <code>task3/edu-irq/</code> in the repository.</p>"},{"location":"asg4/task-pcidev/","title":"Task 1: PCI Device","text":"<p>A PCI (Peripheral Component Interconnect) device is a type of hardware device that connects to a computer's motherboard using the PCI interface. PCI devices can be internal or external and are used for a wide range of applications, such as graphics and audio processing, networking, and storage. The PCI bus is a high-speed data path that allows the CPU to communicate with the device and provides a common interface for a variety of hardware devices. PCI devices are identified by a unique vendor ID and device ID and require a specific driver to communicate with the operating system. They can be added or removed while the computer is running, making them a convenient and flexible option for expanding a system's capabilities.</p> <p>In this task, you will be emulating a PCI device using QEMU and interacting with it. The first step in this process is to set up the QEMU environment.</p>"},{"location":"asg4/task-pcidev/#launch-a-vm-on-qemu","title":"Launch a VM on QEMU","text":"<p>Continuing from the steps outlined in Task 0, add an additional flag to the QEMU command to emulate the PCI EDU device.</p> <pre><code>  -device edu\n</code></pre> <p>You can add more copies of the <code>-device edu</code> flag to create multiple instances of the PCI device.</p>"},{"location":"asg4/task-pcidev/#explore-the-pci-device","title":"Explore the PCI device","text":"<p>Use the <code>lspci</code> command to discover the PCI slot name of the device with a vendor ID of 0x1234 and a device ID of 0x11e8. Refer to the man page of the <code>lspci</code> command for additional information if needed.</p> <p>Question</p> <p>Take a screenshot of the <code>lspci</code> command and its output that shows the name of the slot where the device resides. Highlight the entry relevant to the EDU device device you are emulating.</p> <p>Please adjust the terminal width to 80-120 characters when you take the screenshot, so that the screenshot is easily readable.</p> <p>Linux provides a mechanism to access PCI device resources through the sysfs. You can read the kernel documentation on Accessing PCI device resources through sysfs.</p> <p>You can use the <code>hexdump</code> command or the <code>xxd</code> command to read the content of the PCI device's configuration space. Refer to the specification of the PCI configuration space, available here, to make sense of the output.</p> <p>The file <code>resource0</code> in the directory represents the resource described by the 1st base address register (BAR) (at offset 0x10) in the PCI configuration space. It's specification is available at the \"MMIO area spec\" section of the QEMU documentation. You may find the source code of the device here as well.</p> <p>According to the specification, the reading the first four bytes of the file <code>resource0</code> should yield the value <code>0x010000ed</code>. However, when attempting to read the first four bytes of the file using the <code>head -c 4 resource0</code> command, an \"Input/output error\" is encountered:</p> <pre><code>$ sudo head -c 4 resource0\nhead: error reading 'resource0': Input/output error\n</code></pre> <p>The relevant system calls are as follows:</p> <pre><code>openat(AT_FDCWD, \"resource0\", O_RDONLY) = 3\nread(3, 0x7fffdaf2f780, 4)              = -1 EIO (Input/output error)\n</code></pre> <p>Question</p> <p>Why can't we read from the file <code>resource0</code>?</p> <p>Hint:</p> <ul> <li>According to the documentation, <code>rw</code> access is allowed for <code>IORESOURCE_IO</code> regions only.</li> <li>Refer to the information available from the configuration space.</li> </ul>"},{"location":"asg4/task-pcidev/#access-the-pci-device","title":"Access the PCI device","text":"<p>Since the file is mmapable, we can use the <code>mmap</code> system call to map the file into the process's address space and then access the device's registers. For more information about the <code>mmap</code> system call, you can refer to the man page.</p> <p>Please write a program that accepts two arguments:</p> <ol> <li>The path to the PCI device's \"resource0\".</li> <li>A 32-bit unsigned integer in hexadecimal format.</li> </ol> <p>The program should successfully output the identification of the device and the inversion of the given number.</p> <p>Here's the expected behavior of the program:</p> <pre><code>$ sudo ./pci-mmap /sys/path/to/the/device/resource0 0x11111111\nIdentification: 0x010000edu\n     Inversion: 0xeeeeeeee\n</code></pre> <p>Tip</p> <p>You should be able to accomplish the task by only inserting some lines in the given slot. However, feel free to modify other parts of the code if needed.</p> <p>Question</p> <p>Please write a C program that operates the <code>resource0</code> of the PCI device by mapping it into the process's address space.</p>"}]}